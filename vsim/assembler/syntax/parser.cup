/*
This is the syntax analysis of the VSim simulator. This file
is used with JCup to generate a Parser class. The content of
this file represents all the syntax rules of the RISC-V assembly
language.

Copyright (C) 2018 Andres Castellanos

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>
*/

package vsim.assembler;

import vsim.Globals;
import vsim.Settings;
import vsim.utils.Data;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.io.StringReader;
import vsim.linker.Relocation;
import vsim.assembler.statements.*;


parser code {:

  private static Lexer lexer;
  private static final Parser parser = new Parser();

  public static Object parse(String line) {
    Parser.lexer = new Lexer(new StringReader(line));
    try {
      return Parser.parser.parse();
    } catch (Exception e) {
      /* DO NOTHING */
    }
    return null;
  }

  @Override
  public void syntax_error(Symbol cur_token) {
    /* DO NOTHING */
  }

  @Override
  public void unrecovered_syntax_error(Symbol cur_token) {
    // show all escaped sequences
    if (cur_token.value instanceof String) {
      cur_token.value = ((String) cur_token.value).replaceAll("\n", "\\\\n");
      cur_token.value = ((String) cur_token.value).replaceAll("\r", "\\\\r");
      cur_token.value = ((String) cur_token.value).replaceAll("\b", "\\\\b");
      cur_token.value = ((String) cur_token.value).replaceAll("\f", "\\\\f");
      cur_token.value = ((String) cur_token.value).replaceAll("\0", "\\\\0");
      cur_token.value = ((String) cur_token.value).replaceAll("\t", "\\\\t");
      cur_token.value = ((String) cur_token.value).replaceAll("\u000b", "\\\\v");
    }
    if (cur_token.sym != Token.ERROR)
      Assembler.error(
        "(syntax) invalid statement: unexpected '" + cur_token.value +
        "' (column " + cur_token.right + ")"
      );
    else
      Assembler.error((String)cur_token.value);
  }

:};

scan with {: return Parser.lexer.next_token(); :};

/*  TERMINALS */

// Syntax
terminal DOT, COMMA, LPAREN, RPAREN, LABEL;

// Operators
terminal TIMES, DIVIDE, MOD, PLUS, MINUS, SLL, SRL, SRA, AND, OR, XOR, NEG;
terminal UMINUS, UPLUS;

// B Format
terminal I_BEQ, I_BGE, I_BGEU, I_BLT, I_BLTU, I_BNE;

// U Format
terminal I_LUI, I_AUIPC;

// J Format
terminal I_JAL;

// S Format
terminal I_SB, I_SH, I_SW;
// single-precision floating point
terminal F_FSW;

// R Format
terminal I_ADD, I_AND, I_DIVU, I_DIV, I_MULHSU, I_MULHU;
terminal I_MULH, I_MUL, I_OR, I_REMU, I_REM, I_SLTU;
terminal I_SLL, I_SLT, I_SRA, I_SRL, I_SUB, I_XOR;
// single-precision floating point
terminal F_FMVWX, F_FMVXW, F_FCVTSW, F_FCVTSWU, F_FCVTWS, F_FCVTWUS;
terminal F_FADDS, F_FSUBS, F_FMULS, F_FDIVS, F_FSQRTS;
terminal F_FMADDS, F_FMSUBS, F_FNMSUBS, F_FNMADDS;
terminal F_FSGNJS, F_FSGNJNS, F_FSGNJXS;
terminal F_FMINS, F_FMAXS;
terminal F_FEQS, F_FLTS, F_FLES, F_FCLASSS;
terminal F_FMVS, F_FABSS, F_FNEGS;

// I Format
terminal I_ADDI, I_ANDI, I_ECALL, I_JALR, I_LB;
terminal I_LBU, I_LH, I_LHU, I_LW, I_ORI, I_SLLI;
terminal I_SLTI, I_SLTIU, I_SRAI, I_SRLI, I_XORI;
terminal I_FENCE, I_FENCEI, I_BREAK;
// single-precision floating point
terminal F_FLW;

// Pseudos
terminal I_LA, I_NOP, I_LI, I_MV, I_NOT, I_NEG;
terminal I_SEQZ, I_SNEZ, I_SLTZ, I_SGTZ, I_BEQZ;
terminal I_BNEZ, I_BLEZ, I_BGEZ, I_BLTZ, I_BGTZ;
terminal I_BGT, I_BLE, I_BGTU, I_BLEU, I_J, I_JR;
terminal I_RET, I_CALL, I_TAIL;

// Literals
terminal NUMBER, HEXNUM, BINARY, FLOAT, STRING, CHARACTER;

// Ids and Registers
terminal REGISTER, FREGISTER, IDENTIFIER;

// Directives
terminal D_ASCIIZ, D_ZERO, D_BYTE, D_HALF, D_WORD;
terminal D_SECTION, D_TEXT, D_DATA, D_RODATA, D_BSS;
terminal D_ALIGN, D_BALIGN, D_GLOBL, D_FLOAT;

// error token
terminal ERROR;

/* NON TERMINALS */
non terminal Statement;
non terminal Label;
non terminal Statement Instruction, RISCVInst;
non terminal Statement FRType, RType, IType, SType, BType, UType, JType, R4Type;
non terminal RISCVPSeudo, PSeudos;
non terminal Data;
non terminal String DataMode;
non terminal ArrayList<Integer> DataList;
non terminal ArrayList<Float> FloatList;
non terminal Directive, SectionDir, SymbolDir, AlignDir;
non terminal Section;
non terminal Integer Expr;
non terminal Integer Const;
non terminal String Id;
non terminal String Str;
non terminal Integer Number;
non terminal Integer Hexnum;
non terminal Integer Binary;
non terminal Float Float;
non terminal Integer Character;
non terminal String Register, FRegister;
non terminal Delimiter;
non terminal Epsilon;

/* PRECEDENCE */
precedence left OR;
precedence left XOR;
precedence left AND;
precedence left SLL, SRL, SRA;
precedence left MINUS, PLUS;
precedence left TIMES, MOD, DIVIDE;
precedence right UPLUS, UMINUS, NEG;

/* BNF GRAMMAR */
Statement   ::= Label RISCVInst:i
                {:
                  if (i != null)
                    Assembler.program.add(i);
                :}
             |  Label RISCVPSeudo
             |  Label Data
             |  Label
             |  RISCVInst:i
                {:
                  if (i != null)
                    Assembler.program.add(i);
                :}
             |  RISCVPSeudo
             |  Data
             |  Directive
             ;

Label       ::= LABEL:id
                {:
                  String rawLabel = (String) id;
                  String lbl = rawLabel.substring(0, rawLabel.length() - 1);
                  if (!Assembler.program.addSymbol(Assembler.segment, lbl))
                    Assembler.error("label '" + id + "' is already defined");
                :}
             ;

RISCVInst    ::= Instruction:i
                {:
                  if (!Assembler.inTextSegment())
                    Assembler.error("instructions can appear only in text segment");
                  else
                    RESULT = i;
                :}
             ;

Instruction ::= RType:i
                {: RESULT = i; :}
             |  IType:i
                {: RESULT = i; :}
             |  SType:i
                {: RESULT = i; :}
             |  BType:i
                {: RESULT = i; :}
             |  UType:i
                {: RESULT = i; :}
             |  JType:i
                {: RESULT = i; :}
             |  R4Type:i
                {: RESULT = i; :}
             |  FRType:i
                {: RESULT = i; :}
             ;

RISCVPSeudo ::= PSeudos
                {:
                  if (!Assembler.inTextSegment())
                    Assembler.error("instructions can appear only in text segment");
                  else
                    if (Settings.BARE)
                      Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

/*
  FRTYPE

  fadd.s rd, rs1, rs2
  fsub.s rd, rs1, rs2
  fmul.s rd, rs1, rs2
  fdiv.s rd, rs1, rs2
  fsqrt.s rd, rs1, rs2
  fsgnj.s rd, rs1, rs2
  fsgnjn.s rd, rs1, rs2
  fsgnjx.s rd, rs1, rs2
  fmin.s rd, rs1, rs2
  fmax.s rd, rs1, rs2
  fmv.w.x frd, rs1
  fmv.x.w rd, frs1
  fcvt.s.w frd, rs1
  fcvt.s.wu frd, rs1
  fcvt.w.s rd, frs1
  fcvt.wu.s rd, frs1
  feq.s rd, frs1, frs2
  flt.s rd, frs1, frs2
  fle.s rd, frs1, frs2
  fclass.s rd, frs1
  fmv.s rd, rs
  fabs.s rd, rs
  fneg.s rd, rs
*/

FRType      ::= F_FADDS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {: RESULT = new FRType("fadd.s", Assembler.debug, rd, rs1, rs2); :}
             |  F_FSUBS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {: RESULT = new FRType("fsub.s", Assembler.debug, rd, rs1, rs2); :}
             |  F_FMULS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {: RESULT = new FRType("fmul.s", Assembler.debug, rd, rs1, rs2); :}
             |  F_FDIVS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {: RESULT = new FRType("fdiv.s", Assembler.debug, rd, rs1, rs2); :}
             |  F_FSQRTS FRegister:rd Delimiter FRegister:rs1
                {: RESULT = new FRType("fsqrt.s", Assembler.debug, rd, rs1, "f0"); :}
             |  F_FSGNJS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {: RESULT = new FRType("fsgnj.s", Assembler.debug, rd, rs1, rs2); :}
             |  F_FSGNJNS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {: RESULT = new FRType("fsgnjn.s", Assembler.debug, rd, rs1, rs2); :}
             |  F_FSGNJXS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {: RESULT = new FRType("fsgnjx.s", Assembler.debug, rd, rs1, rs2); :}
             |  F_FMINS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {: RESULT = new FRType("fmin.s", Assembler.debug, rd, rs1, rs2); :}
             |  F_FMAXS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {: RESULT = new FRType("fmax.s", Assembler.debug, rd, rs1, rs2); :}
             |  F_FMVXW Register:rd Delimiter FRegister:rs1
                {:
                  // hack to re-use FRType Statement
                  int num = Globals.regfile.getRegisterNumber(rd);
                  RESULT = new FRType("fmv.x.w", Assembler.debug, "f" + num, rs1, "f0");
                :}
             |  F_FMVWX FRegister:rd Delimiter Register:rs1
                {:
                  // hack to re-use FRType Statement
                  int num = Globals.regfile.getRegisterNumber(rs1);
                  RESULT = new FRType("fmv.w.x", Assembler.debug, rd, "f" + num, "f0");
                :}
             |  F_FCVTSW FRegister:rd Delimiter Register:rs1
                {:
                  // hack to re-use FRType Statement
                  int num = Globals.regfile.getRegisterNumber(rs1);
                  RESULT = new FRType("fcvt.s.w", Assembler.debug, rd, "f" + num, "f0");
                :}
             |  F_FCVTSWU FRegister:rd Delimiter Register:rs1
                {:
                  // hack to re-use FRType Statement
                  int num = Globals.regfile.getRegisterNumber(rs1);
                  RESULT = new FRType("fcvt.s.wu", Assembler.debug, rd, "f" + num, "f1");
                :}
             |  F_FCVTWS Register:rd Delimiter FRegister:rs1
                {:
                  // hack to re-use FRType Statement
                  int num = Globals.regfile.getRegisterNumber(rd);
                  RESULT = new FRType("fcvt.w.s", Assembler.debug, "f" + num, rs1, "f0");
                :}
             |  F_FCVTWUS Register:rd Delimiter FRegister:rs1
                {:
                  // hack to re-use FRType Statement
                  int num = Globals.regfile.getRegisterNumber(rd);
                  RESULT = new FRType("fcvt.wu.s", Assembler.debug, "f" + num, rs1, "f1");
                :}
             |  F_FEQS Register:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {:
                  // hack to re-use FRType Statement
                  int num = Globals.regfile.getRegisterNumber(rd);
                  RESULT = new FRType("feq.s", Assembler.debug, "f" + num, rs1, rs2);
                :}
             |  F_FLTS Register:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {:
                  // hack to re-use FRType Statement
                  int num = Globals.regfile.getRegisterNumber(rd);
                  RESULT = new FRType("flt.s", Assembler.debug, "f" + num, rs1, rs2);
                :}
             |  F_FLES Register:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2
                {:
                  // hack to re-use FRType Statement
                  int num = Globals.regfile.getRegisterNumber(rd);
                  RESULT = new FRType("fle.s", Assembler.debug, "f" + num, rs1, rs2);
                :}
             |  F_FCLASSS Register:rd Delimiter FRegister:rs1
                {:
                  // hack to re-use FRType Statement
                  int num = Globals.regfile.getRegisterNumber(rd);
                  RESULT = new FRType("fclass.s", Assembler.debug, "f" + num, rs1, "f1");
                :}
             |  F_FMVS FRegister:rd Delimiter FRegister:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new FRType("fsgnj.s", Assembler.debug, rd, rs, rs);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  F_FABSS FRegister:rd Delimiter FRegister:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new FRType("fsgnjx.s", Assembler.debug, rd, rs, rs);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  F_FNEGS FRegister:rd Delimiter FRegister:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new FRType("fsgnjn.s", Assembler.debug, rd, rs, rs);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

/*
  R4TYPE

  fmadd.s rd, rs1, rs2, rs3
  fmsub.s rd, rs1, rs2, rs3
  fnmadd.s rd, rs1, rs2, rs3
  fnmsub.s rd, rs1, rs2, rs3
*/

R4Type      ::= F_FMADDS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2 Delimiter FRegister:rs3
                {: RESULT = new R4Type("fmadd.s", Assembler.debug, rd, rs1, rs2, rs3); :}
             |  F_FMSUBS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2 Delimiter FRegister:rs3
                {: RESULT = new R4Type("fmsub.s", Assembler.debug, rd, rs1, rs2, rs3); :}
             |  F_FNMADDS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2 Delimiter FRegister:rs3
                {: RESULT = new R4Type("fnmadd.s", Assembler.debug, rd, rs1, rs2, rs3); :}
             |  F_FNMSUBS FRegister:rd Delimiter FRegister:rs1 Delimiter FRegister:rs2 Delimiter FRegister:rs3
                {: RESULT = new R4Type("fnmsub.s", Assembler.debug, rd, rs1, rs2, rs3); :}
             ;

/*
  RTYPE
  sll rd, rs1, rs2
  srl rd, rs1, rs2
  sra rd, rs1, rs2
  add rd, rs1, rs2
  sub rd, rs1, rs2
  xor rd, rs1, rs2
  or rd, rs1, rs2
  and rd, rs1, rs2
  slt rd, rs1, rs2
  sltu rd, rs1, rs2
  mul rd, rs1, rs2
  mulh rd, rs1, rs2
  mulhsu rd, rs1, rs2
  mulhu rd, rs1, rs2
  div rd, rs1, rs2
  divu rd, rs1, rs2
  rem rd, rs1, rs2
  remu rd, rs1, rs2
  neg rd, rs
  snez rd, rs
  sltz rd, rs
  sgtz rd, rs
*/

RType       ::= I_SLL Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("sll", Assembler.debug, rd, rs1, rs2); :}
             |  I_SRL Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("srl", Assembler.debug, rd, rs1, rs2); :}
             |  I_SRA Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("sra", Assembler.debug, rd, rs1, rs2); :}
             |  I_ADD Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("add", Assembler.debug, rd, rs1, rs2); :}
             |  I_SUB Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("sub", Assembler.debug, rd, rs1, rs2); :}
             |  I_XOR Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("xor", Assembler.debug, rd, rs1, rs2); :}
             |  I_OR Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("or", Assembler.debug, rd, rs1, rs2); :}
             |  I_AND Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("and", Assembler.debug, rd, rs1, rs2); :}
             |  I_SLT Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("slt", Assembler.debug, rd, rs1, rs2); :}
             |  I_SLTU Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("sltu", Assembler.debug, rd, rs1, rs2); :}
             |  I_MUL Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("mul", Assembler.debug, rd, rs1, rs2); :}
             |  I_MULH Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("mulh", Assembler.debug, rd, rs1, rs2); :}
             |  I_MULHSU Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("mulhsu", Assembler.debug, rd, rs1, rs2); :}
             |  I_MULHU Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("mulhu", Assembler.debug, rd, rs1, rs2); :}
             |  I_DIV Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("div", Assembler.debug, rd, rs1, rs2); :}
             |  I_DIVU Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("divu", Assembler.debug, rd, rs1, rs2); :}
             |  I_REM Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("rem", Assembler.debug, rd, rs1, rs2); :}
             |  I_REMU Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType("remu", Assembler.debug, rd, rs1, rs2); :}
             |  I_NEG Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType("sub", Assembler.debug, rd, "x0", rs);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SNEZ Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType("sltu", Assembler.debug, rd, "x0", rs);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SLTZ Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType("slt", Assembler.debug, rd, rs, "x0");
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SGTZ Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType("slt", Assembler.debug, rd, "x0", rs);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

/*
  ITYPE

  slli rd, rs1, shamt
  srli rd, rs1, shamt
  srai rd, rs1, shamt
  addi rd, rs1, imm
  xori rd, rs1, imm
  ori  rd, rs1, imm
  andi rd, rs1, imm
  slti rd, rs1, imm
  sltiu rd, rs1, imm
  jalr rd, rs1, imm
  lb rd, offset(rs1)
  lbu rd, offset(rs1)
  lh rd, offset(rs1)
  lhu rd, offset(rs1)
  lw rd, offset(rs1)
  ecall
  fence
  fence.i
  nop
  mv rd, rs
  not rd, rs
  seqz rd, rs
  jr rs
  jalr rs
  ret
  lb rd, symbol
  lh rd, symbol
  lw rd, symbol
  flw frd, offset(rs1)
  flw frd, symbol, rt
*/

IType       ::= I_ADDI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new IType("addi", Assembler.debug, rd, rs1, imm); :}
             |  I_XORI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new IType("xori", Assembler.debug, rd, rs1, imm); :}
             |  I_ORI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new IType("ori", Assembler.debug, rd, rs1, imm); :}
             |  I_ANDI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new IType("andi", Assembler.debug, rd, rs1, imm); :}
             |  I_SLTI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new IType("slti", Assembler.debug, rd, rs1, imm); :}
             |  I_SLTIU Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new IType("sltiu", Assembler.debug, rd, rs1, imm); :}
             |  I_SLLI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new Shift("slli", Assembler.debug, rd, rs1, imm); :}
             |  I_SRLI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new Shift("srli", Assembler.debug, rd, rs1, imm); :}
             |  I_SRAI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new Shift("srai", Assembler.debug, rd, rs1, imm); :}
             |  I_JALR Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new IType("jalr", Assembler.debug, rd, rs1, imm); :}
             |  I_LB Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType("lb", Assembler.debug, rd, rs1, offset); :}
             |  I_LBU Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType("lbu", Assembler.debug, rd, rs1, offset); :}
             |  I_LH Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType("lh", Assembler.debug, rd, rs1, offset); :}
             |  I_LHU Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType("lhu", Assembler.debug, rd, rs1, offset); :}
             |  I_LW Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType("lw", Assembler.debug, rd, rs1, offset); :}
             |  I_ECALL
                {: RESULT = new IType("ecall", Assembler.debug, "x0", "x0", 0); :}
             |  I_BREAK
                {: RESULT = new IType("ebreak", Assembler.debug, "x0", "x0", 1); :}
             |  I_FENCE
                {: RESULT = new IType("fence", Assembler.debug, "x0", "x0", 0); :}
             |  I_FENCEI
                {: RESULT = new IType("fence.i", Assembler.debug, "x0", "x0", 0); :}
             |  F_FLW FRegister:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {:
                  // hack to re-use IType Statement
                  int num = Globals.fregfile.getRegisterNumber(rd);
                  RESULT = new IType("flw", Assembler.debug, "x" + num, rs1, offset);
                :}
             |  I_NOP
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("addi", Assembler.debug, "x0", "x0", 0);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_MV Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("addi", Assembler.debug, rd, rs, 0);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_NOT Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("xori", Assembler.debug, rd, rs, -1);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SEQZ Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("sltiu", Assembler.debug, rd, rs, 1);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_JR Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("jalr", Assembler.debug, "x0", rs, 0);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_JALR Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("jalr", Assembler.debug, "x1", rs, 0);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_RET
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("jalr", Assembler.debug, "x0", "x1", 0);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
              |  I_LB Register:rd Delimiter Id:id
                 {:
                    if (!Settings.BARE) {
                      Assembler.program.add(new UType("auipc", Assembler.debug, rd, new Relocation(Relocation.PCRELHI, id)));
                      Assembler.program.add(new IType("lb", Assembler.debug, rd, rd, new Relocation(Relocation.PCRELLO, id)));
                    } else
                      Assembler.error("invalid instruction: use -asm flag to use pseudos");
                 :}
              |  I_LH Register:rd Delimiter Id:id
                 {:
                    if (!Settings.BARE) {
                      Assembler.program.add(new UType("auipc", Assembler.debug, rd, new Relocation(Relocation.PCRELHI, id)));
                      Assembler.program.add(new IType("lh", Assembler.debug, rd, rd, new Relocation(Relocation.PCRELLO, id)));
                    } else
                      Assembler.error("invalid instruction: use -asm flag to use pseudos");
                 :}
              |  I_LW Register:rd Delimiter Id:id
                 {:
                    if (!Settings.BARE) {
                      Assembler.program.add(new UType("auipc", Assembler.debug, rd, new Relocation(Relocation.PCRELHI, id)));
                      Assembler.program.add(new IType("lw", Assembler.debug, rd, rd, new Relocation(Relocation.PCRELLO, id)));
                    } else
                      Assembler.error("invalid instruction: use -asm flag to use pseudos");
                 :}
              |  F_FLW FRegister:rd Delimiter Id:id Delimiter Register:rt
                 {:
                    if (!Settings.BARE) {
                      // hack to re-use IType Statement
                      int num = Globals.fregfile.getRegisterNumber(rd);
                      Assembler.program.add(new UType("auipc", Assembler.debug, rt, new Relocation(Relocation.PCRELHI, id)));
                      Assembler.program.add(new IType("flw", Assembler.debug, "x" + num, rt, new Relocation(Relocation.PCRELLO, id)));
                    } else
                      Assembler.error("invalid instruction: use -asm flag to use pseudos");
                 :}
             ;

/*
  STYPE

  sb rs2, offset(rs1)
  sh rs2, offset(rs1)
  sw rs2, offset(rs1)
  sb rd, symbol, rt
  sh rd, symbol, rt
  sw rd, symbol, rt
*/

SType       ::= I_SB Register:rs2 Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new SType("sb", Assembler.debug, rs1, rs2, offset); :}
             |  I_SH Register:rs2 Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new SType("sh", Assembler.debug, rs1, rs2, offset); :}
             |  I_SW Register:rs2 Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new SType("sw", Assembler.debug, rs1, rs2, offset); :}
             |  F_FSW FRegister:rs2 Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {:
                  // hack to re-use SType Statement
                  int num = Globals.fregfile.getRegisterNumber(rs2);
                  RESULT = new SType("fsw", Assembler.debug, rs1, "x" + num, offset);
                :}
             |  I_SB Register:rd Delimiter Id:id Delimiter Register:rt
                {:
                  if (!Settings.BARE) {
                    Assembler.program.add(new UType("auipc", Assembler.debug, rt, new Relocation(Relocation.PCRELHI, id)));
                    Assembler.program.add(new SType("sb", Assembler.debug, rt, rd, new Relocation(Relocation.PCRELLO, id)));
                  } else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SH Register:rd Delimiter Id:id Delimiter Register:rt
                {:
                  if (!Settings.BARE) {
                    Assembler.program.add(new UType("auipc", Assembler.debug, rt, new Relocation(Relocation.PCRELHI, id)));
                    Assembler.program.add(new SType("sh", Assembler.debug, rt, rd, new Relocation(Relocation.PCRELLO, id)));
                  } else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SW Register:rd Delimiter Id:id Delimiter Register:rt
                {:
                  if (!Settings.BARE) {
                    Assembler.program.add(new UType("auipc", Assembler.debug, rt, new Relocation(Relocation.PCRELHI, id)));
                    Assembler.program.add(new SType("sw", Assembler.debug, rt, rd, new Relocation(Relocation.PCRELLO, id)));
                  } else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  F_FSW FRegister:rd Delimiter Id:id Delimiter Register:rt
                {:
                  if (!Settings.BARE) {
                    // hack to re-use SType Statement
                    int num = Globals.fregfile.getRegisterNumber(rd);
                    Assembler.program.add(new UType("auipc", Assembler.debug, rt, new Relocation(Relocation.PCRELHI, id)));
                    Assembler.program.add(new SType("fsw", Assembler.debug, rt, "x" + num, new Relocation(Relocation.PCRELLO, id)));
                  } else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

/*
  BTYPE

  beq rs1, rs2, symbol
  bne rs1, rs2, symbol
  blt rs1, rs2, symbol
  bge rs1, rs2, symbol
  bltu rs1, rs2, symbol
  bgeu rs1, rs2, symbol
  beqz rs, symbol
  bnez rs, symbol
  blez rs, symbol
  bgez rs, symbol
  bltz rs, symbol
  bgtz rs, symbol
  bgt rs1, rs2, symbol
  ble rs1, rs2, symbol
  bgtu rs1, rs2, symbol
  bleu rs1, rs2, symbol
*/

BType       ::= I_BEQ Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {: RESULT = new BType("beq", Assembler.debug, rs1, rs2, id); :}
             |  I_BNE Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {: RESULT = new BType("bne", Assembler.debug, rs1, rs2, id); :}
             |  I_BLT Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {: RESULT = new BType("blt", Assembler.debug, rs1, rs2, id); :}
             |  I_BGE Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {: RESULT = new BType("bge", Assembler.debug, rs1, rs2, id); :}
             |  I_BLTU Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {: RESULT = new BType("bltu", Assembler.debug, rs1, rs2, id); :}
             |  I_BGEU Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {: RESULT = new BType("bgeu", Assembler.debug, rs1, rs2, id); :}
             |  I_BEQZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("beq", Assembler.debug, rs, "x0", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BNEZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bne", Assembler.debug, rs, "x0", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BLEZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bge", Assembler.debug, "x0", rs, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BGEZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bge", Assembler.debug, rs, "x0", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BLTZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("blt", Assembler.debug, rs, "x0", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BGTZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("blt", Assembler.debug, "x0", rs, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BGT Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("blt", Assembler.debug, rs2, rs1, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BLE Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bge", Assembler.debug, rs2, rs1, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BGTU Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bltu", Assembler.debug, rs2, rs1, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BLEU Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bgeu", Assembler.debug, rs2, rs1, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

/*
  UTYPE

  auipc rd, imm
  lui rd, imm
*/

UType       ::= I_AUIPC Register:rd Delimiter Const:imm
                {: RESULT = new UType("auipc", Assembler.debug, rd, imm); :}
             |  I_LUI   Register:rd Delimiter Const:imm
                {: RESULT = new UType("lui", Assembler.debug, rd, imm); :}
             ;

/*
  JTYPE

  jal rd, symbol
  jal symbol
  j symbol
*/

JType       ::= I_JAL Register:rd Delimiter Id:id
                {: RESULT = new JType("jal", Assembler.debug, rd, id); :}
             |  I_JAL Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new JType("jal", Assembler.debug, "x1", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_J Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new JType("jal", Assembler.debug, "x0", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

/*
  PSEUDOS

  la rd, symbol
  li, imm
  call symbol
  tail symbol
*/

PSeudos     ::= I_LA Register:rd Delimiter Id:id
                {:
                  Assembler.program.add(new UType("auipc", Assembler.debug, rd, new Relocation(Relocation.PCRELHI, id)));
                  Assembler.program.add(new IType("addi", Assembler.debug, rd, rd, new Relocation(Relocation.PCRELLO, id)));
                :}
             |  I_LI Register:rd Delimiter Const:imm
                {:
                  if (imm > 2047 || imm < -2048) {
                    int imm_hi =  ((imm >>> 12) + ((imm >>> 11) & 0x1)) & 0x000fffff;
                    int imm_lo = Data.signExtend((imm & 0xfff), 12);
                    Assembler.program.add(new UType("lui", Assembler.debug, rd, imm_hi));
                    Assembler.program.add(new IType("addi", Assembler.debug, rd, rd, imm_lo));
                  } else {
                    Assembler.program.add(new IType("addi", Assembler.debug, rd, "x0", imm));
                  }
                :}
             |  I_CALL Id:id
                {:
                  Assembler.program.add(new UType("auipc", Assembler.debug, "x6", new Relocation(Relocation.PCRELHI, id)));
                  Assembler.program.add(new IType("jalr", Assembler.debug, "x1", "x6", new Relocation(Relocation.PCRELLO, id)));
                :}
             |  I_TAIL Id:id
                {:
                  Assembler.program.add(new UType("auipc", Assembler.debug, "x6", new Relocation(Relocation.PCRELHI, id)));
                  Assembler.program.add(new IType("jalr", Assembler.debug, "x0", "x6", new Relocation(Relocation.PCRELLO, id)));
                :}
             ;
/*
  DATA

  [.word, .half, .byte] expr [, expr]*
  .asciiz str
  .zero expr
  .comm id, size, align
  .float float [, float]*
*/

Data        ::= DataMode:mode DataList:l
                {:
                  if (Assembler.inDataSegment() || Assembler.inRodataSegment()) {
                    // set mask and length
                    int mask = Data.WORD_MASK;
                    int length = Data.WORD_LENGTH;
                    if (mode.equals(".byte")) {
                      mask = Data.BYTE_MASK;
                      length = Data.BYTE_LENGTH;
                    } else if (mode.equals(".half")) {
                      mask = Data.HALF_MASK;
                      length = Data.HALF_LENGTH;
                    }
                    for (int i = 0; i < l.size(); i++) {
                      int value = l.get(i);
                      // lossy conversion ?
                      if (mask == Data.BYTE_MASK && !Data.validByte(value) && !Settings.QUIET)
                        Assembler.warning("lossy conversion to byte: '" + value + "' -> " + (value & mask));
                      if (mask == Data.HALF_MASK && !Data.validHalf(value) && !Settings.QUIET)
                        Assembler.warning("lossy conversion to half: '" + value + "' -> " + (value & mask));
                      // store byte by byte
                      for (int j = 0; j < length; j++) {
                        byte byteVal = (byte)((value >>> (j * Data.BYTE_LENGTH_BITS)) & Data.BYTE_MASK);
                        Assembler.program.addByte(Assembler.segment, byteVal);
                      }
                    }
                  } else
                    Assembler.error(mode + " directive can not appear in " + Assembler.segment + " segment");
                :}
             |  D_ASCIIZ:mode Str:s
                {:
                  if (Assembler.inDataSegment() || Assembler.inRodataSegment()) {
                    // scan char by char
                    for (int i = 0; i < s.length(); i++)
                      Assembler.program.addByte(Assembler.segment, (byte) s.charAt(i));
                    // null terminate string
                    Assembler.program.addByte(Assembler.segment, (byte) 0);
                  } else
                    Assembler.error(".asciiz directive can not appear in " + Assembler.segment + " segment");
                :}
             |  D_ZERO Expr:e
                {:
                  if (e > 0) {
                    if (!Assembler.inTextSegment())
                      for (int i = 0; i < e; i++)
                        Assembler.program.addByte(Assembler.segment, (byte) 0);
                    else
                      Assembler.error(".zero directive can not appear in text segment");
                  } else
                    Assembler.error("invalid .zero argument: '" + e + "', expected value > 0");
                :}
             |  D_FLOAT FloatList:l
                {:
                  if (Assembler.inDataSegment() || Assembler.inRodataSegment()) {
                    // set mask and length
                    int mask = Data.WORD_MASK;
                    int length = Data.WORD_LENGTH;
                    for (int i = 0; i < l.size(); i++) {
                      int value = Float.floatToIntBits(l.get(i));
                      // store byte by byte
                      for (int j = 0; j < length; j++) {
                        byte byteVal = (byte)((value >>> (j * Data.BYTE_LENGTH_BITS)) & Data.BYTE_MASK);
                        Assembler.program.addByte(Assembler.segment, byteVal);
                      }
                    }
                  } else
                    Assembler.error(".float directive can not appear in " + Assembler.segment + " segment");
                :}
             ;

DataMode    ::= D_BYTE:d
                {: RESULT = (String)d; :}
             |  D_HALF:d
                {: RESULT = (String)d; :}
             |  D_WORD:d
                {: RESULT = (String)d; :}
             ;

DataList    ::= Expr:e
                {:
                  ArrayList<Integer> l = new ArrayList<Integer>();
                  l.add(e);
                  RESULT = l;
                :}
             |  DataList:l Delimiter Expr:e
                {:
                  l.add(e);
                  RESULT = l;
                :}
             ;

FloatList   ::= Float:f
                {:
                  ArrayList<Float> l = new ArrayList<Float>();
                  l.add(f);
                  RESULT = l;
                :}
             |  NUMBER:n
                {:
                  ArrayList<Float> l = new ArrayList<Float>();
                  l.add((float)((int) n));
                  RESULT = l;
                :}
             |  FloatList:l Delimiter NUMBER:n
                {:
                  l.add((float)((int)n));
                  RESULT = l;
                :}
             |  FloatList:l Delimiter Float:f
                {:
                  l.add(f);
                  RESULT = l;
                :}
             ;

/*
  DIRECTIVES
*/

Directive   ::= SectionDir
             |  SymbolDir
             |  AlignDir
             |  DOT Id:id
                {: Assembler.error("invalid directive: '." + id + "'"); :}
             ;

/*
  .section [{.text, .data, .rodata, .bss}]
*/

SectionDir  ::= D_SECTION Section
             |  Section
             ;

/*
  .text
  .data
  .rodata
  .bss
*/
Section     ::= D_TEXT:s
                {: Assembler.segment = Segment.TEXT; :}
             |  D_DATA:s
                {: Assembler.segment = Segment.DATA; :}
             |  D_RODATA:s
                {: Assembler.segment = Segment.RODATA; :}
             |  D_BSS:s
                {: Assembler.segment = Segment.BSS; :}
             ;

/*
  .globl id
*/

SymbolDir   ::= D_GLOBL Id:id
                {:
                  if(!Assembler.program.addGlobal(id))
                    Assembler.error("label '" + id + "' is already defined as global");
                :}
             ;

/*
  .align n
  .balign n
*/

AlignDir    ::= D_ALIGN Number:e
                {:
                  if (!Assembler.inTextSegment()) {
                    if (e >= 0 && e <= 2)
                      Assembler.program.align(e);
                    else
                      Assembler.error("invalid align value: '" + e + "', expected 0 (byte), 1 (half) or 2 (word)");
                  } else
                    Assembler.error(".align directive can not appear in text segment");
                :}
             |  D_BALIGN Number:e
                {:
                  if (!Assembler.inTextSegment()) {
                    if (e > 0)
                      Assembler.program.balign(e);
                    else
                      Assembler.error("invalid align value: '" + e + "', expected value > 0");
                  } else
                    Assembler.error(".balign directive can not appear in text segment");
                :}
             ;

/*
    VALUES
*/

Expr        ::= Expr:e1 PLUS Expr:e2
                {: RESULT = e1 + e2; :}
             |  Expr:e1 MINUS Expr:e2
                {: RESULT = e1 - e2; :}
             |  Expr:e1 TIMES Expr:e2
                {: RESULT = e1 * e2; :}
             |  Expr:e1 DIVIDE Expr:e2
                {: RESULT = e1 / e2; :}
             |  Expr:e1 MOD Expr:e2
                {: RESULT = e1 % e2; :}
             |  Expr:e1 SLL Expr:e2
                {: RESULT = e1 << e2; :}
             |  Expr:e1 SRL Expr:e2
                {: RESULT = e1 >>> e2; :}
             |  Expr:e1 SRA Expr:e2
                {: RESULT = e1 >> e2; :}
             |  Expr:e1 AND Expr:e2
                {: RESULT = e1 & e2; :}
             |  Expr:e1 OR Expr:e2
                {: RESULT = e1 | e2; :}
             |  Expr:e1 XOR Expr:e2
                {: RESULT = e1 ^ e2; :}
             |  LPAREN Expr:e RPAREN
                {: RESULT = e; :}
             |  MINUS Expr:e
                {: RESULT = -e; :}
                %prec UMINUS
             |  PLUS Expr:e
                {: RESULT = e; :}
                %prec UPLUS
             |  NEG Expr:e
                {: RESULT = ~e; :}
             |  Const:n
                {: RESULT = n; :}
             ;

Const       ::= Number:n
                {: RESULT = n; :}
             |  Character:c
                {: RESULT = c; :}
             ;

Id          ::= IDENTIFIER:id
                {: RESULT = (String)id; :}
             ;

Number      ::= NUMBER:n
                {: RESULT = (int)n; :}
             |  Hexnum:n
                {: RESULT = n; :}
             |  Binary:n
                {: RESULT = n; :}
             ;

Hexnum      ::= HEXNUM:n
                {: RESULT = (int)n; :}
             ;

Binary      ::= BINARY:n
                {: RESULT = (int)n; :}
             ;

Float       ::= FLOAT:f
                {: RESULT = (float)f; :}
             |  Hexnum:n
                {: RESULT = Float.intBitsToFloat(n); :}
             |  Binary:n
                {: RESULT = Float.intBitsToFloat(n); :}
             ;

Character   ::= CHARACTER:c
                {: RESULT = (int)(((char) c) & 0xff); :}
             ;

Str         ::= STRING:s
                {: RESULT = (String)s; :}
             ;

Register    ::= REGISTER:reg
                {: RESULT = (String)reg; :}
             ;

FRegister   ::= FREGISTER:reg
                {: RESULT = (String)reg; :}
             ;

Delimiter   ::= COMMA
             |  Epsilon
             ;

Epsilon     ::= /* NOTHING */
             ;
