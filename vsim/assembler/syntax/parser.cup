package vsim.assembler;

import vsim.Settings;
import vsim.utils.Data;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.io.StringReader;
import vsim.assembler.pseudos.*;
import vsim.assembler.statements.*;


parser code {:

  private static Lexer lexer;
  private static final Parser parser = new Parser();

  public static Object parse(String line) {
    Parser.lexer = new Lexer(new StringReader(line));
    try {
      return Parser.parser.parse();
    } catch (Exception e) {
      /* DO NOTHING */
    }
    return null;
  }

  public static void invalidInst(String opcode) {
    Assembler.error("invalid instruction: '" + opcode + "', change assembler mode with -asm flag");
  }

  public void syntax_error(Symbol cur_token) {
    /* DO NOTHING */
  }

  public void unrecovered_syntax_error(Symbol cur_token) {
    if (cur_token.sym != Token.ERROR)
      Assembler.error(
        "(syntax) unexpected input: " + cur_token.value +
        " (column " + cur_token.right + ")"
      );
    else
      Assembler.error(
        cur_token.value +
        " (column " + cur_token.right + ")"
      );
  }

:};

scan with {: return Parser.lexer.next_token(); :};

/*  TERMINALS */

// Syntax
terminal DOT, COMMA, COLON, LPAREN, RPAREN;

// Operators
terminal TIMES, DIVIDE, MOD, PLUS, MINUS, SLL, SRL, SRA, AND, OR, XOR, NEG;
terminal UMINUS, UPLUS;

// B Format
terminal I_BEQ, I_BGE, I_BGEU, I_BLT, I_BLTU, I_BNE;

// U Format
terminal I_LUI, I_AUIPC;

// J Format
terminal I_JAL;

// S Format
terminal I_SB, I_SH, I_SW;

// R Format
terminal I_ADD, I_AND, I_DIVU, I_DIV, I_MULHSU, I_MULHU;
terminal I_MULH, I_MUL, I_OR, I_REMU, I_REM, I_SLTU;
terminal I_SLL, I_SLT, I_SRA, I_SRL, I_SUB, I_XOR;

// I Format
terminal I_ADDI, I_ANDI, I_ECALL, I_JALR, I_LB;
terminal I_LBU, I_LH, I_LHU, I_LW, I_ORI, I_SLLI;
terminal I_SLTI, I_SLTIU, I_SRAI, I_SRLI, I_XORI;

// Pseudos
terminal I_LA, I_NOP, I_LI, I_MV, I_NOT, I_NEG;
terminal I_SEQZ, I_SNEZ, I_SLTZ, I_SGTZ, I_BEQZ;
terminal I_BNEZ, I_BLEZ, I_BGEZ, I_BLTZ, I_BGTZ;
terminal I_BGT, I_BLE, I_BGTU, I_BLEU, I_J, I_JR;
terminal I_RET, I_CALL, I_TAIL;

// Literals
terminal NUMBER, STRING, CHARACTER;

// Ids and Registers
terminal REGISTER, IDENTIFIER;

// Directives
terminal D_STRING, D_ASCIIZ, D_ZERO, D_BYTE, D_HALF, D_WORD;
terminal D_SECTION, D_TEXT, D_DATA, D_RODATA, D_BSS;
terminal D_ALIGN, D_BALIGN, D_GLOBL, D_COMM;

// error token
terminal ERROR;

/* NON TERMINALS */
non terminal Statement;
non terminal Label;
non terminal Statement Instruction, RISCVInst;
non terminal Statement RType, IType, SType, BType, UType, JType;
non terminal PSeudo RISCVPSeudo, PSeudos;
non terminal String ROpCode, IOpCode, SOpCode, BOpCode;
non terminal Data;
non terminal String DataMode;
non terminal ArrayList<Integer> DataList;
non terminal Directive, SectionDir, SymbolDir, AlignDir;
non terminal Section;
non terminal Integer Expr;
non terminal Integer Const;
non terminal String Id;
non terminal String Str;
non terminal Integer Number;
non terminal Integer Character;
non terminal String Register;
non terminal Delimiter;
non terminal Epsilon;

/* PRECEDENCE */
precedence left OR;
precedence left XOR;
precedence left AND;
precedence left SLL, SRL, SRA;
precedence left MINUS, PLUS;
precedence left TIMES, MOD, DIVIDE;
precedence right UPLUS, UMINUS, NEG;

/* BNF GRAMMAR */
Statement   ::= Label RISCVInst:i
                {:
                  if (i != null)
                    Assembler.program.add(i);
                :}
             |  Label RISCVPSeudo:p
                {:
                  ArrayList<Statement> stmts = p.build(Assembler.program.getFilename());
                  for (Statement stmt: stmts)
                    Assembler.program.add(stmt);
                :}
             |  Label Data
             |  Label
             |  RISCVInst:i
                {:
                  if (i != null)
                    Assembler.program.add(i);
                :}
             |  RISCVPSeudo:p
                {:
                  ArrayList<Statement> stmts = p.build(Assembler.program.getFilename());
                  for (Statement stmt: stmts)
                    Assembler.program.add(stmt);
                :}
             |  Data
             |  Directive
             ;

Label       ::= Id:id COLON
                {:
                  if (!Assembler.program.addSymbol(id))
                    Assembler.error("label '" + id + "' is already defined");
                :}
             ;

RISCVInst    ::= Instruction:i
                {:
                  if (!Assembler.program.inTextSegment())
                    Assembler.error("instructions can appear only in text segment");
                  else
                    RESULT = i;
                :}
             ;

Instruction ::= RType:i
                {: RESULT = i; :}
             |  IType:i
                {: RESULT = i; :}
             |  SType:i
                {: RESULT = i; :}
             |  BType:i
                {: RESULT = i; :}
             |  UType:i
                {: RESULT = i; :}
             |  JType:i
                {: RESULT = i; :}
             ;

RISCVPSeudo ::= PSeudos:p
                {:
                  if (!Assembler.program.inTextSegment())
                    Assembler.error("instructions can appear only in text segment");
                  else
                    RESULT = p;
                :}
             ;

RType       ::= ROpCode:opcode Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType(Assembler.program.getFilename(), opcode, rd, rs1, rs2); :}
             |  I_NEG:opcode Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType(Assembler.program.getFilename(), "sub", rd, "x0", rs);
                  else
                    Parser.invalidInst("neg");
                :}
             |  I_SNEZ:opcode Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType(Assembler.program.getFilename(), "sltu", rd, "x0", rs);
                  else
                    Parser.invalidInst("snez");
                :}
             |  I_SLTZ:opcode Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType(Assembler.program.getFilename(), "slt", rd, rs, "x0");
                  else
                    Parser.invalidInst("sltz");
                :}
             |  I_SGTZ:opcode Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType(Assembler.program.getFilename(), "slt", rd, "x0", rs);
                  else
                    Parser.invalidInst("sgtz");
                :}
             ;

ROpCode     ::= I_SLL:opcode
                {: RESULT = (String)opcode; :}
             |  I_SRL:opcode
                {: RESULT = (String)opcode; :}
             |  I_SRA:opcode
                {: RESULT = (String)opcode; :}
             |  I_ADD:opcode
                {: RESULT = (String)opcode; :}
             |  I_SUB:opcode
                {: RESULT = (String)opcode; :}
             |  I_XOR:opcode
                {: RESULT = (String)opcode; :}
             |  I_OR:opcode
                {: RESULT = (String)opcode; :}
             |  I_AND:opcode
                {: RESULT = (String)opcode; :}
             |  I_SLT:opcode
                {: RESULT = (String)opcode; :}
             |  I_SLTU:opcode
                {: RESULT = (String)opcode; :}
             |  I_MUL:opcode
                {: RESULT = (String)opcode; :}
             |  I_MULH:opcode
                {: RESULT = (String)opcode; :}
             |  I_MULHSU:opcode
                {: RESULT = (String)opcode; :}
             |  I_MULHU:opcode
                {: RESULT = (String)opcode; :}
             |  I_DIV:opcode
                {: RESULT = (String)opcode; :}
             |  I_DIVU:opcode
                {: RESULT = (String)opcode; :}
             |  I_REM:opcode
                {: RESULT = (String)opcode; :}
             |  I_REMU:opcode
                {: RESULT = (String)opcode; :}
             ;

IType       ::= IOpCode:opcode Register:rd Delimiter Register:rs1 Delimiter Number:imm
                {: RESULT = new IType(Assembler.program.getFilename(), opcode, rd, rs1, imm); :}
             |  I_SLLI Register:rd Delimiter Register:rs1 Delimiter Number:imm
                {: RESULT = new Shift(Assembler.program.getFilename(), "slli", rd, rs1, imm); :}
             |  I_SRLI Register:rd Delimiter Register:rs1 Delimiter Number:imm
                {: RESULT = new Shift(Assembler.program.getFilename(), "srli", rd, rs1, imm); :}
             |  I_SRAI Register:rd Delimiter Register:rs1 Delimiter Number:imm
                {: RESULT = new Shift(Assembler.program.getFilename(), "srai", rd, rs1, imm); :}
             |  I_JALR Register:rd Delimiter Register:rs1 Delimiter Number:imm
                {: RESULT = new IType(Assembler.program.getFilename(), "jalr", rd, rs1, imm); :}
             |  I_LB Register:rd Delimiter Register:rs1 Delimiter Number:imm
                {: RESULT = new IType(Assembler.program.getFilename(), "lb", rd, rs1, imm); :}
             |  I_LBU Register:rd Delimiter Register:rs1 Delimiter Number:imm
                {: RESULT = new IType(Assembler.program.getFilename(), "lbu", rd, rs1, imm); :}
             |  I_LH Register:rd Delimiter Register:rs1 Delimiter Number:imm
                {: RESULT = new IType(Assembler.program.getFilename(), "lh", rd, rs1, imm); :}
             |  I_LHU Register:rd Delimiter Register:rs1 Delimiter Number:imm
                {: RESULT = new IType(Assembler.program.getFilename(), "lhu", rd, rs1, imm); :}
             |  I_LW Register:rd Delimiter Register:rs1 Delimiter Number:imm
                {: RESULT = new IType(Assembler.program.getFilename(), "lw", rd, rs1, imm); :}
             |  I_LB Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType(Assembler.program.getFilename(), "lb", rd, rs1, offset); :}
             |  I_LBU Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType(Assembler.program.getFilename(), "lbu", rd, rs1, offset); :}
             |  I_LH Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType(Assembler.program.getFilename(), "lh", rd, rs1, offset); :}
             |  I_LHU Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType(Assembler.program.getFilename(), "lhu", rd, rs1, offset); :}
             |  I_LW Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType(Assembler.program.getFilename(), "lw", rd, rs1, offset); :}
             |  I_ECALL
                {: RESULT = new IType(Assembler.program.getFilename(), "ecall", "x0", "x0", 0); :}
             |  I_NOP
                {:
                  if (!Settings.BARE)
                    RESULT = new IType(Assembler.program.getFilename(), "addi", "x0", "x0", 0);
                  else
                    Parser.invalidInst("nop");
                :}
             |  I_MV Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType(Assembler.program.getFilename(), "addi", rd, rs, 0);
                  else
                    Parser.invalidInst("mv");
                :}
             |  I_NOT Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType(Assembler.program.getFilename(), "xori", rd, rs, -1);
                  else
                    Parser.invalidInst("not");
                :}
             |  I_SEQZ Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType(Assembler.program.getFilename(), "sltiu", rd, rs, 1);
                  else
                    Parser.invalidInst("seqz");
                :}
             |  I_JR Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType(Assembler.program.getFilename(), "jalr", "x0", rs, 0);
                  else
                    Parser.invalidInst("jr");
                :}
             |  I_JALR Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType(Assembler.program.getFilename(), "jalr", "x1", rs, 0);
                  else
                    Parser.invalidInst("jalr, rs");
                :}
             |  I_RET
                {:
                  if (!Settings.BARE)
                    RESULT = new IType(Assembler.program.getFilename(), "jalr", "x0", "x1", 0);
                  else
                    Parser.invalidInst("ret");
                :}
             ;

IOpCode     ::= I_ADDI:opcode
                {: RESULT = (String)opcode; :}
             |  I_XORI:opcode
                {: RESULT = (String)opcode; :}
             |  I_ORI:opcode
                {: RESULT = (String)opcode; :}
             |  I_ANDI:opcode
                {: RESULT = (String)opcode; :}
             |  I_SLTI:opcode
                {: RESULT = (String)opcode; :}
             |  I_SLTIU:opcode
                {: RESULT = (String)opcode; :}
             ;

SType       ::= SOpCode:opcode Register:rs1 Delimiter Register:rs2 Number:imm
                {: RESULT = new SType(Assembler.program.getFilename(), opcode, rs1, rs2, imm); :}
             |  SOpCode:opcode Register:rs2 Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new SType(Assembler.program.getFilename(), opcode, rs1, rs2, offset); :}
             ;

SOpCode     ::= I_SB:opcode
                {: RESULT = (String)opcode; :}
             |  I_SH:opcode
                {: RESULT = (String)opcode; :}
             |  I_SW:opcode
                {: RESULT = (String)opcode; :}
             ;

BType       ::= BOpCode:opcode Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {: RESULT = new BType(Assembler.program.getFilename(), opcode, rs1, rs2, id); :}
             |  I_BEQZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType(Assembler.program.getFilename(), "beq", rs, "x0", id);
                  else
                    Parser.invalidInst("beqz");
                :}
             |  I_BNEZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType(Assembler.program.getFilename(), "bne", rs, "x0", id);
                  else
                    Parser.invalidInst("bnez");
                :}
             |  I_BLEZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType(Assembler.program.getFilename(), "bge", "x0", rs, id);
                  else
                    Parser.invalidInst("blez");
                :}
             |  I_BGEZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType(Assembler.program.getFilename(), "bge", rs, "x0", id);
                  else
                    Parser.invalidInst("bgez");
                :}
             |  I_BLTZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType(Assembler.program.getFilename(), "blt", rs, "x0", id);
                  else
                    Parser.invalidInst("bltz");
                :}
             |  I_BGTZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType(Assembler.program.getFilename(), "blt", "x0", rs, id);
                  else
                    Parser.invalidInst("bgtz");
                :}
             |  I_BGT Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType(Assembler.program.getFilename(), "blt", rs2, rs1, id);
                  else
                    Parser.invalidInst("bgt");
                :}
             |  I_BLE Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType(Assembler.program.getFilename(), "bge", rs2, rs1, id);
                  else
                    Parser.invalidInst("ble");
                :}
             |  I_BGTU Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType(Assembler.program.getFilename(), "bltu", rs2, rs1, id);
                  else
                    Parser.invalidInst("bgtu");
                :}
             |  I_BLEU Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType(Assembler.program.getFilename(), "bgeu", rs2, rs1, id);
                  else
                    Parser.invalidInst("bleu");
                :}
             ;

BOpCode     ::= I_BEQ:opcode
                {: RESULT = (String)opcode; :}
             |  I_BNE:opcode
                {: RESULT = (String)opcode; :}
             |  I_BLT:opcode
                {: RESULT = (String)opcode; :}
             |  I_BGE:opcode
                {: RESULT = (String)opcode; :}
             |  I_BLTU:opcode
                {: RESULT = (String)opcode; :}
             |  I_BGEU:opcode
                {: RESULT = (String)opcode; :}
             ;

UType       ::= I_AUIPC Register:rd Delimiter Number:imm
                {: RESULT = new UType(Assembler.program.getFilename(), "auipc", rd, imm); :}
             |  I_LUI   Register:rd Delimiter Number:imm
                {: RESULT = new UType(Assembler.program.getFilename(), "lui", rd, imm); :}
             ;

JType       ::= I_JAL Register:rd Delimiter Id:id
                {: RESULT = new JType(Assembler.program.getFilename(), "jal", rd, id); :}
             |  I_JAL Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new JType(Assembler.program.getFilename(), "jal", "x1", id);
                  else
                    Parser.invalidInst("jal, target");
                :}
             |  I_J Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new JType(Assembler.program.getFilename(), "jal", "x0", id);
                  else
                    Parser.invalidInst("j");
                :}
             ;

PSeudos     ::= I_LA Register:rd Delimiter Id:id
                {: RESULT = new La(rd, id); :}
             |  I_LI Register:rd Delimiter Number:n
                {: RESULT = new Li(rd, n); :}
             |  I_CALL Id:id
                {: RESULT = new Call(id); :}
             |  I_TAIL Id:id
                {: RESULT = new Tail(id); :}
             ;

/*
    DATA
*/

Data        ::= DataMode:mode DataList:l
                {:
                  if (Assembler.program.inDataSegment() || Assembler.program.inRodataSegment()) {
                    int mask = -1;
                    int length = Data.WORD_LENGTH;
                    if (mode.equals(".byte")) {
                      mask = Data.BYTE_MASK;
                      length = Data.BYTE_LENGTH;
                    }
                    else if (mode.equals(".half") || mode.equals(".short") || mode.equals(".2byte")) {
                      mask = Data.HALF_MASK;
                      length = Data.HALF_LENGTH;
                    }
                    for (int i = 0; i < l.size(); i++) {
                      int value = l.get(i);
                      if (mask == Data.BYTE_MASK && Data.validByte(value))
                        Assembler.warning("lossy conversion to byte: '" + value + "' -> " + (value & mask));
                      if (mask == Data.HALF_MASK && Data.validHalf(value))
                        Assembler.warning("lossy conversion to half: '" + value + "' -> " + (value & mask));
                      for (int j = 0; j < length; j++)
                        Assembler.program.addByte((byte)((value >>> j * Data.BYTE_LENGTH_BITS) & mask));
                    }
                  }
                  else
                    Assembler.error(mode + " directive can not appear in " + Assembler.program.getSegment() + " segment");
                :}
             |  D_STRING:mode Str:s
                {:
                  if (Assembler.program.inDataSegment() || Assembler.program.inRodataSegment()) {
                    for (int i = 0; i < s.length(); i++)
                      Assembler.program.addByte((byte) s.charAt(i));
                    Assembler.program.addByte((byte) 0);
                  } else
                    Assembler.error(".string directive can not appear in " + Assembler.program.getSegment() + " segment");
                :}
             |  D_ASCIIZ:mode Str:s
                {:
                  if (Assembler.program.inDataSegment() || Assembler.program.inRodataSegment()) {
                    for (int i = 0; i < s.length(); i++)
                      Assembler.program.addByte((byte) s.charAt(i));
                    Assembler.program.addByte((byte) 0);
                  } else
                    Assembler.error(".asciiz directive can not appear in " + Assembler.program.getSegment() + " segment");
                :}
             |  D_ZERO Expr:e
                {:
                  if (!Assembler.program.inTextSegment())
                    for (int i = 0; i < e; i++)
                      Assembler.program.addByte((byte) 0);
                  else
                    Assembler.error(".zero directive can not appear in text segment");
                :}
             |  D_COMM Id:id Delimiter Expr:size Delimiter Expr:align
                {:
                  if (Assembler.program.inBssSegment()) {
                    if (align >= 0 && align <= 2) {
                      Assembler.program.alignVal(align);
                      if (!Assembler.program.addSymbol(id))
                        Assembler.error("label '" + id + "' is already defined");
                      else {
                        for (int i = 0; i < size; i++)
                          Assembler.program.addByte((byte) 0);
                      }
                    } else
                      Assembler.error(
                        "invalid align value: '" + align + "', expected 0, 1 or 2"
                      );
                  } else
                    Assembler.error(".comm/.common directive can only appear in bss segment");
                :}
             ;

DataMode    ::= D_BYTE:d
                {: RESULT = (String)d; :}
             |  D_HALF:d
                {: RESULT = (String)d; :}
             |  D_WORD:d
                {: RESULT = (String)d; :}
             ;

DataList    ::= Expr:e
                {:
                  ArrayList<Integer> l = new ArrayList<Integer>();
                  l.add(e);
                  RESULT = l;
                :}
             |  DataList:l Delimiter Expr:e
                {:
                  l.add(e);
                  RESULT = l;
                :}
             ;

/*
    DIRECTIVES
*/

Directive   ::= SectionDir
             |  SymbolDir
             |  AlignDir
             |  DOT Id:id
                {: Assembler.error("invalid directive: '." + id + "'"); :}
             ;

/*
  .section [{.text, .data, .rodata, .bss}]
*/

SectionDir  ::= D_SECTION Section
             |  Section
             ;

Section     ::= D_TEXT:s
                {: Assembler.program.setSegment(Segment.TEXT); :}
             |  D_DATA:s
                {: Assembler.program.setSegment(Segment.DATA); :}
             |  D_RODATA:s
                {: Assembler.program.setSegment(Segment.RODATA); :}
             |  D_BSS:s
                {: Assembler.program.setSegment(Segment.BSS); :}
             ;

/*
  .globl id
*/

SymbolDir   ::= D_GLOBL Id:id
                {:
                  if(!Assembler.program.addGlobal(id))
                    Assembler.error("label '" + id + "' is already defined as global");
                :}
             ;

/*
  .align n
  .p2align n
  .balign n
*/

AlignDir    ::= D_ALIGN Number:e
                {:
                  if (!Assembler.program.inTextSegment()) {
                    if (e >= 0 && e <= 2)
                      Assembler.program.alignVal(e);
                    else
                      Assembler.error(
                        "invalid align value: '" + e + "', expected 0, 1 or 2"
                      );
                  } else
                    Assembler.error(
                      ".align/.p2align directives can not appear in text segment"
                    );
                :}
             |  D_BALIGN Number:e
                {:
                  if (!Assembler.program.inTextSegment()) {
                    if (e > 0)
                      Assembler.program.balignVal(e);
                    else
                      Assembler.error(
                        "invalid align value: '" + e + "', expected value > 0"
                      );
                  } else
                    Assembler.error(
                      ".balign directive can not appear in text segment"
                    );
                :}
             ;

/*
    VALUES
*/

Expr        ::= Expr:e1 PLUS Expr:e2
                {: RESULT = e1 + e2; :}
             |  Expr:e1 MINUS Expr:e2
                {: RESULT = e1 - e2; :}
             |  Expr:e1 TIMES Expr:e2
                {: RESULT = e1 * e2; :}
             |  Expr:e1 DIVIDE Expr:e2
                {: RESULT = e1 / e2; :}
             |  Expr:e1 MOD Expr:e2
                {: RESULT = e1 % e2; :}
             |  Expr:e1 SLL Expr:e2
                {: RESULT = e1 << e2; :}
             |  Expr:e1 SRL Expr:e2
                {: RESULT = e1 >>> e2; :}
             |  Expr:e1 SRA Expr:e2
                {: RESULT = e1 >> e2; :}
             |  Expr:e1 AND Expr:e2
                {: RESULT = e1 & e2; :}
             |  Expr:e1 OR Expr:e2
                {: RESULT = e1 | e2; :}
             |  Expr:e1 XOR Expr:e2
                {: RESULT = e1 ^ e2; :}
             |  LPAREN Expr:e RPAREN
                {: RESULT = e; :}
             |  MINUS Expr:e
                {: RESULT = -e; :}
                %prec UMINUS
             |  PLUS Expr:e
                {: RESULT = e; :}
                %prec UPLUS
             |  NEG Expr:e
                {: RESULT = ~e; :}
             |  Const:n
                {: RESULT = n; :}
             ;

Const       ::= Number:n
                {: RESULT = n; :}
             |  Character:c
                {: RESULT = c; :}
             ;

Id          ::= IDENTIFIER:id
                {: RESULT = (String)id; :}
             ;

Number      ::= NUMBER:n
                {: RESULT = (int)n; :}
             ;

Character   ::= CHARACTER:c
                {: RESULT = (int)(((char) c) & 0xff); :}
             ;

Str         ::= STRING:s
                {: RESULT = (String)s; :}
             ;

Register    ::= REGISTER:reg
                {: RESULT = (String)reg; :}
             ;

Delimiter   ::= COMMA
             |  Epsilon
             ;

Epsilon     ::= /* NOTHING */
             ;
