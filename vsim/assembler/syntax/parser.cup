package vsim.assembler;

import vsim.Settings;
import vsim.utils.Data;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.io.StringReader;
import vsim.linker.Relocation;
import vsim.assembler.statements.*;


parser code {:

  private static Lexer lexer;
  private static final Parser parser = new Parser();

  public static Object parse(String line) {
    Parser.lexer = new Lexer(new StringReader(line));
    try {
      return Parser.parser.parse();
    } catch (Exception e) {
      /* DO NOTHING */
    }
    return null;
  }

  public void syntax_error(Symbol cur_token) {
    /* DO NOTHING */
  }

  public void unrecovered_syntax_error(Symbol cur_token) {
    if (cur_token.value instanceof String) {
      cur_token.value = ((String) cur_token.value).replaceAll("\n", "\\\\n");
      cur_token.value = ((String) cur_token.value).replaceAll("\r", "\\\\r");
      cur_token.value = ((String) cur_token.value).replaceAll("\b", "\\\\b");
      cur_token.value = ((String) cur_token.value).replaceAll("\f", "\\\\f");
      cur_token.value = ((String) cur_token.value).replaceAll("\0", "\\\\0");
      cur_token.value = ((String) cur_token.value).replaceAll("\t", "\\\\t");
      cur_token.value = ((String) cur_token.value).replaceAll("\u000b", "\\\\v");
    }
    if (cur_token.sym != Token.ERROR)
      Assembler.error(
        "(syntax) invalid statement: unexpected '" + cur_token.value +
        "' (column " + cur_token.right + ")"
      );
    else
      Assembler.error((String)cur_token.value);
  }

:};

scan with {: return Parser.lexer.next_token(); :};

/*  TERMINALS */

// Syntax
terminal DOT, COMMA, LPAREN, RPAREN, LABEL;

// Operators
terminal TIMES, DIVIDE, MOD, PLUS, MINUS, SLL, SRL, SRA, AND, OR, XOR, NEG;
terminal UMINUS, UPLUS;

// B Format
terminal I_BEQ, I_BGE, I_BGEU, I_BLT, I_BLTU, I_BNE;

// U Format
terminal I_LUI, I_AUIPC;

// J Format
terminal I_JAL;

// S Format
terminal I_SB, I_SH, I_SW;

// R Format
terminal I_ADD, I_AND, I_DIVU, I_DIV, I_MULHSU, I_MULHU;
terminal I_MULH, I_MUL, I_OR, I_REMU, I_REM, I_SLTU;
terminal I_SLL, I_SLT, I_SRA, I_SRL, I_SUB, I_XOR;

// I Format
terminal I_ADDI, I_ANDI, I_ECALL, I_JALR, I_LB;
terminal I_LBU, I_LH, I_LHU, I_LW, I_ORI, I_SLLI;
terminal I_SLTI, I_SLTIU, I_SRAI, I_SRLI, I_XORI;

// Pseudos
terminal I_LA, I_NOP, I_LI, I_MV, I_NOT, I_NEG;
terminal I_SEQZ, I_SNEZ, I_SLTZ, I_SGTZ, I_BEQZ;
terminal I_BNEZ, I_BLEZ, I_BGEZ, I_BLTZ, I_BGTZ;
terminal I_BGT, I_BLE, I_BGTU, I_BLEU, I_J, I_JR;
terminal I_RET, I_CALL, I_TAIL;

// Literals
terminal NUMBER, STRING, CHARACTER;

// Ids and Registers
terminal REGISTER, IDENTIFIER;

// Directives
terminal D_ASCIIZ, D_ZERO, D_BYTE, D_HALF, D_WORD;
terminal D_SECTION, D_TEXT, D_DATA, D_RODATA, D_BSS;
terminal D_ALIGN, D_BALIGN, D_GLOBL, D_COMM;

// error token
terminal ERROR;

/* NON TERMINALS */
non terminal Statement;
non terminal Label;
non terminal Statement Instruction, RISCVInst;
non terminal Statement RType, IType, SType, BType, UType, JType;
non terminal RISCVPSeudo, PSeudos;
non terminal String ROpCode, IOpCode, BOpCode;
non terminal Data;
non terminal String DataMode;
non terminal ArrayList<Integer> DataList;
non terminal Directive, SectionDir, SymbolDir, AlignDir;
non terminal Section;
non terminal Integer Expr;
non terminal Integer Const;
non terminal String Id;
non terminal String Str;
non terminal Integer Number;
non terminal Integer Character;
non terminal String Register;
non terminal Delimiter;
non terminal Epsilon;

/* PRECEDENCE */
precedence left OR;
precedence left XOR;
precedence left AND;
precedence left SLL, SRL, SRA;
precedence left MINUS, PLUS;
precedence left TIMES, MOD, DIVIDE;
precedence right UPLUS, UMINUS, NEG;

/* BNF GRAMMAR */
Statement   ::= Label RISCVInst:i
                {:
                  if (i != null)
                    Assembler.program.add(i);
                :}
             |  Label RISCVPSeudo
             |  Label Data
             |  Label
             |  RISCVInst:i
                {:
                  if (i != null)
                    Assembler.program.add(i);
                :}
             |  RISCVPSeudo
             |  Data
             |  Directive
             ;

Label       ::= LABEL:id
                {:
                  String rawLabel = (String) id;
                  String lbl = rawLabel.substring(0, rawLabel.length() - 1);
                  if (!Assembler.program.addSymbol(Assembler.segment, lbl))
                    Assembler.error("label '" + id + "' is already defined");
                :}
             ;

RISCVInst    ::= Instruction:i
                {:
                  if (!Assembler.inTextSegment())
                    Assembler.error("instructions can appear only in text segment");
                  else
                    RESULT = i;
                :}
             ;

Instruction ::= RType:i
                {: RESULT = i; :}
             |  IType:i
                {: RESULT = i; :}
             |  SType:i
                {: RESULT = i; :}
             |  BType:i
                {: RESULT = i; :}
             |  UType:i
                {: RESULT = i; :}
             |  JType:i
                {: RESULT = i; :}
             ;

RISCVPSeudo ::= PSeudos
                {:
                  if (!Assembler.inTextSegment())
                    Assembler.error("instructions can appear only in text segment");
                  else
                    if (Settings.BARE)
                      Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

/*
  RTYPE
  sll rd, rs1, rs2
  srl rd, rs1, rs2
  sra rd, rs1, rs2
  add rd, rs1, rs2
  sub rd, rs1, rs2
  xor rd, rs1, rs2
  or rd, rs1, rs2
  and rd, rs1, rs2
  slt rd, rs1, rs2
  sltu rd, rs1, rs2
  mul rd, rs1, rs2
  mulh rd, rs1, rs2
  mulhsu rd, rs1, rs2
  mulhu rd, rs1, rs2
  div rd, rs1, rs2
  divu rd, rs1, rs2
  rem rd, rs1, rs2
  remu rd, rs1, rs2
*/

RType       ::= ROpCode:opcode Register:rd Delimiter Register:rs1 Delimiter Register:rs2
                {: RESULT = new RType(opcode, Assembler.debug, rd, rs1, rs2); :}
             |  I_NEG:opcode Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType("sub", Assembler.debug, rd, "x0", rs);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SNEZ:opcode Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType("sltu", Assembler.debug, rd, "x0", rs);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SLTZ:opcode Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType("slt", Assembler.debug, rd, rs, "x0");
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SGTZ:opcode Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new RType("slt", Assembler.debug, rd, "x0", rs);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

ROpCode     ::= I_SLL:opcode
                {: RESULT = (String)opcode; :}
             |  I_SRL:opcode
                {: RESULT = (String)opcode; :}
             |  I_SRA:opcode
                {: RESULT = (String)opcode; :}
             |  I_ADD:opcode
                {: RESULT = (String)opcode; :}
             |  I_SUB:opcode
                {: RESULT = (String)opcode; :}
             |  I_XOR:opcode
                {: RESULT = (String)opcode; :}
             |  I_OR:opcode
                {: RESULT = (String)opcode; :}
             |  I_AND:opcode
                {: RESULT = (String)opcode; :}
             |  I_SLT:opcode
                {: RESULT = (String)opcode; :}
             |  I_SLTU:opcode
                {: RESULT = (String)opcode; :}
             |  I_MUL:opcode
                {: RESULT = (String)opcode; :}
             |  I_MULH:opcode
                {: RESULT = (String)opcode; :}
             |  I_MULHSU:opcode
                {: RESULT = (String)opcode; :}
             |  I_MULHU:opcode
                {: RESULT = (String)opcode; :}
             |  I_DIV:opcode
                {: RESULT = (String)opcode; :}
             |  I_DIVU:opcode
                {: RESULT = (String)opcode; :}
             |  I_REM:opcode
                {: RESULT = (String)opcode; :}
             |  I_REMU:opcode
                {: RESULT = (String)opcode; :}
             ;

/*
  ITYPE

  slli rd, rs1, shamt
  srli rd, rs1, shamt
  srai rd, rs1, shamt
  addi rd, rs1, imm
  xori rd, rs1, imm
  ori  rd, rs1, imm
  andi rd, rs1, imm
  slti rd, rs1, imm
  sltiu rd, rs1, imm
  jalr rd, rs1, imm
  lb rd, offset(rs1)
  lbu rd, offset(rs1)
  lh rd, offset(rs1)
  lhu rd, offset(rs1)
  lw rd, offset(rs1)
  ecall
  nop
  mv rd, rs
  not rd, rs
  seqz rd, rs
  jr rs
  jalr rs
  ret
  lb rd, symbol
  lh rd, symbol
  lw rd, symbol
*/

IType       ::= IOpCode:opcode Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new IType(opcode, Assembler.debug, rd, rs1, imm); :}
             |  I_SLLI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new Shift("slli", Assembler.debug, rd, rs1, imm); :}
             |  I_SRLI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new Shift("srli", Assembler.debug, rd, rs1, imm); :}
             |  I_SRAI Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new Shift("srai", Assembler.debug, rd, rs1, imm); :}
             |  I_JALR Register:rd Delimiter Register:rs1 Delimiter Const:imm
                {: RESULT = new IType("jalr", Assembler.debug, rd, rs1, imm); :}
             |  I_LB Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType("lb", Assembler.debug, rd, rs1, offset); :}
             |  I_LBU Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType("lbu", Assembler.debug, rd, rs1, offset); :}
             |  I_LH Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType("lh", Assembler.debug, rd, rs1, offset); :}
             |  I_LHU Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType("lhu", Assembler.debug, rd, rs1, offset); :}
             |  I_LW Register:rd Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new IType("lw", Assembler.debug, rd, rs1, offset); :}
             |  I_ECALL
                {: RESULT = new IType("ecall", Assembler.debug, "x0", "x0", 0); :}
             |  I_NOP
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("addi", Assembler.debug, "x0", "x0", 0);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_MV Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("addi", Assembler.debug, rd, rs, 0);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_NOT Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("xori", Assembler.debug, rd, rs, -1);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SEQZ Register:rd Delimiter Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("sltiu", Assembler.debug, rd, rs, 1);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_JR Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("jalr", Assembler.debug, "x0", rs, 0);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_JALR Register:rs
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("jalr", Assembler.debug, "x1", rs, 0);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_RET
                {:
                  if (!Settings.BARE)
                    RESULT = new IType("jalr", Assembler.debug, "x0", "x1", 0);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
              |  I_LB Register:rd Delimiter Id:id
                 {:
                    if (!Settings.BARE) {
                      Assembler.program.add(new UType("auipc", Assembler.debug, rd, new Relocation(Relocation.PCRELHI, id)));
                      Assembler.program.add(new IType("lb", Assembler.debug, rd, rd, new Relocation(Relocation.PCRELLO, id)));
                    } else
                      Assembler.error("invalid instruction: use -asm flag to use pseudos");
                 :}
              |  I_LH Register:rd Delimiter Id:id
                 {:
                    if (!Settings.BARE) {
                      Assembler.program.add(new UType("auipc", Assembler.debug, rd, new Relocation(Relocation.PCRELHI, id)));
                      Assembler.program.add(new IType("lh", Assembler.debug, rd, rd, new Relocation(Relocation.PCRELLO, id)));
                    } else
                      Assembler.error("invalid instruction: use -asm flag to use pseudos");
                 :}
              |  I_LW Register:rd Delimiter Id:id
                 {:
                    if (!Settings.BARE) {
                      Assembler.program.add(new UType("auipc", Assembler.debug, rd, new Relocation(Relocation.PCRELHI, id)));
                      Assembler.program.add(new IType("lw", Assembler.debug, rd, rd, new Relocation(Relocation.PCRELLO, id)));
                    } else
                      Assembler.error("invalid instruction: use -asm flag to use pseudos");
                 :}
             ;

IOpCode     ::= I_ADDI:opcode
                {: RESULT = (String)opcode; :}
             |  I_XORI:opcode
                {: RESULT = (String)opcode; :}
             |  I_ORI:opcode
                {: RESULT = (String)opcode; :}
             |  I_ANDI:opcode
                {: RESULT = (String)opcode; :}
             |  I_SLTI:opcode
                {: RESULT = (String)opcode; :}
             |  I_SLTIU:opcode
                {: RESULT = (String)opcode; :}
             ;

/*
  STYPE

  sb rs2, offset(rs1)
  sh rs2, offset(rs1)
  sw rs2, offset(rs1)
  sb rd, symbol, rt
  sh rd, symbol, rt
  sw rd, symbol, rt
*/

SType       ::= I_SB Register:rs2 Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new SType("sb", Assembler.debug, rs1, rs2, offset); :}
             |  I_SH Register:rs2 Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new SType("sh", Assembler.debug, rs1, rs2, offset); :}
             |  I_SW Register:rs2 Delimiter Number:offset LPAREN Register:rs1 RPAREN
                {: RESULT = new SType("sw", Assembler.debug, rs1, rs2, offset); :}
             |  I_SB Register:rd Delimiter Id:id Delimiter Register:rt
                {:
                  if (!Settings.BARE) {
                    Assembler.program.add(new UType("auipc", Assembler.debug, rt, new Relocation(Relocation.PCRELHI, id)));
                    Assembler.program.add(new SType("sb", Assembler.debug, rt, rd, new Relocation(Relocation.PCRELLO, id)));
                  } else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SH Register:rd Delimiter Id:id Delimiter Register:rt
                {:
                  if (!Settings.BARE) {
                    Assembler.program.add(new UType("auipc", Assembler.debug, rt, new Relocation(Relocation.PCRELHI, id)));
                    Assembler.program.add(new SType("sh", Assembler.debug, rt, rd, new Relocation(Relocation.PCRELLO, id)));
                  } else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_SW Register:rd Delimiter Id:id Delimiter Register:rt
                {:
                  if (!Settings.BARE) {
                    Assembler.program.add(new UType("auipc", Assembler.debug, rt, new Relocation(Relocation.PCRELHI, id)));
                    Assembler.program.add(new SType("sw", Assembler.debug, rt, rd, new Relocation(Relocation.PCRELLO, id)));
                  } else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

/*
  BTYPE

  beq rs1, rs2, symbol
  bne rs1, rs2, symbol
  blt rs1, rs2, symbol
  bge rs1, rs2, symbol
  bltu rs1, rs2, symbol
  bgeu rs1, rs2, symbol
  beqz rs, symbol
  bnez rs, symbol
  blez rs, symbol
  bgez rs, symbol
  bltz rs, symbol
  bgtz rs, symbol
  bgt rs1, rs2, symbol
  ble rs1, rs2, symbol
  bgtu rs1, rs2, symbol
  bleu rs1, rs2, symbol
*/

BType       ::= BOpCode:opcode Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {: RESULT = new BType(opcode, Assembler.debug, rs1, rs2, id); :}
             |  I_BEQZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("beq", Assembler.debug, rs, "x0", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BNEZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bne", Assembler.debug, rs, "x0", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BLEZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bge", Assembler.debug, "x0", rs, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BGEZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bge", Assembler.debug, rs, "x0", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BLTZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("blt", Assembler.debug, rs, "x0", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BGTZ Register:rs Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("blt", Assembler.debug, "x0", rs, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BGT Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("blt", Assembler.debug, rs2, rs1, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BLE Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bge", Assembler.debug, rs2, rs1, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BGTU Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bltu", Assembler.debug, rs2, rs1, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_BLEU Register:rs1 Delimiter Register:rs2 Delimiter Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new BType("bgeu", Assembler.debug, rs2, rs1, id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

BOpCode     ::= I_BEQ:opcode
                {: RESULT = (String)opcode; :}
             |  I_BNE:opcode
                {: RESULT = (String)opcode; :}
             |  I_BLT:opcode
                {: RESULT = (String)opcode; :}
             |  I_BGE:opcode
                {: RESULT = (String)opcode; :}
             |  I_BLTU:opcode
                {: RESULT = (String)opcode; :}
             |  I_BGEU:opcode
                {: RESULT = (String)opcode; :}
             ;

/*
  UTYPE

  auipc rd, imm
  lui rd, imm
*/

UType       ::= I_AUIPC Register:rd Delimiter Const:imm
                {: RESULT = new UType("auipc", Assembler.debug, rd, imm); :}
             |  I_LUI   Register:rd Delimiter Const:imm
                {: RESULT = new UType("lui", Assembler.debug, rd, imm); :}
             ;

/*
  JTYPE

  jal rd, symbol
  jal symbol
  j symbol
*/

JType       ::= I_JAL Register:rd Delimiter Id:id
                {: RESULT = new JType("jal", Assembler.debug, rd, id); :}
             |  I_JAL Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new JType("jal", Assembler.debug, "x1", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             |  I_J Id:id
                {:
                  if (!Settings.BARE)
                    RESULT = new JType("jal", Assembler.debug, "x0", id);
                  else
                    Assembler.error("invalid instruction: use -asm flag to use pseudos");
                :}
             ;

/*
  PSEUDOS

  la rd, symbol
  li, imm
  call symbol
  tail symbol
*/

PSeudos     ::= I_LA Register:rd Delimiter Id:id
                {:
                  Assembler.program.add(new UType("auipc", Assembler.debug, rd, new Relocation(Relocation.PCRELHI, id)));
                  Assembler.program.add(new IType("addi", Assembler.debug, rd, rd, new Relocation(Relocation.PCRELLO, id)));
                :}
             |  I_LI Register:rd Delimiter Const:imm
                {:
                  if (imm > 2047 || imm < -2048) {
                    int imm_hi = imm >>> 12;
                    int imm_lo = Data.signExtend(imm & 0xfff, 12);
                    Assembler.program.add(new UType("lui", Assembler.debug, rd, imm_hi));
                    Assembler.program.add(new IType("addi", Assembler.debug, rd, rd, imm_lo));
                  } else {
                    Assembler.program.add(new IType("addi", Assembler.debug, rd, "x0", imm));
                  }
                :}
             |  I_CALL Id:id
                {:
                  Assembler.program.add(new UType("auipc", Assembler.debug, "x6", new Relocation(Relocation.PCRELHI, id)));
                  Assembler.program.add(new IType("jalr", Assembler.debug, "x1", "x6", new Relocation(Relocation.PCRELLO, id)));
                :}
             |  I_TAIL Id:id
                {:
                  Assembler.program.add(new UType("auipc", Assembler.debug, "x6", new Relocation(Relocation.PCRELHI, id)));
                  Assembler.program.add(new IType("jalr", Assembler.debug, "x0", "x6", new Relocation(Relocation.PCRELLO, id)));
                :}
             ;
/*
  DATA

  [.word, .half, .byte] expr [, expr]*
  .asciiz str
  .zero expr
  .comm id, size, align
*/

Data        ::= DataMode:mode DataList:l
                {:
                  if (Assembler.inDataSegment() || Assembler.inRodataSegment()) {
                    // set mask and length
                    int mask = Data.WORD_MASK;
                    int length = Data.WORD_LENGTH;
                    if (mode.equals(".byte")) {
                      mask = Data.BYTE_MASK;
                      length = Data.BYTE_LENGTH;
                    } else if (mode.equals(".half")) {
                      mask = Data.HALF_MASK;
                      length = Data.HALF_LENGTH;
                    }
                    for (int i = 0; i < l.size(); i++) {
                      int value = l.get(i);
                      // lossy conversion ?
                      if (mask == Data.BYTE_MASK && !Data.validByte(value))
                        Assembler.warning("lossy conversion to byte: '" + value + "' -> " + (value & mask));
                      if (mask == Data.HALF_MASK && !Data.validHalf(value))
                        Assembler.warning("lossy conversion to half: '" + value + "' -> " + (value & mask));
                      // store byte by byte
                      for (int j = 0; j < length; j++) {
                        byte byteVal = (byte)((value >>> (j * Data.BYTE_LENGTH_BITS)) & Data.BYTE_MASK);
                        Assembler.program.addByte(Assembler.segment, byteVal);
                      }
                    }
                  } else
                    Assembler.error(mode + " directive can not appear in " + Assembler.segment + " segment");
                :}
             |  D_ASCIIZ:mode Str:s
                {:
                  if (Assembler.inDataSegment() || Assembler.inRodataSegment()) {
                    // scan char by char
                    for (int i = 0; i < s.length(); i++)
                      Assembler.program.addByte(Assembler.segment, (byte) s.charAt(i));
                    // null terminate string
                    Assembler.program.addByte(Assembler.segment, (byte) 0);
                  } else
                    Assembler.error(".asciiz directive can not appear in " + Assembler.segment + " segment");
                :}
             |  D_ZERO Expr:e
                {:
                  if (!Assembler.inTextSegment())
                    for (int i = 0; i < e; i++)
                      Assembler.program.addByte(Assembler.segment, (byte) 0);
                  else
                    Assembler.error(".zero directive can not appear in text segment");
                :}
             |  D_COMM Id:id Delimiter Expr:size Delimiter Expr:align
                {:
                  if (Assembler.inBssSegment()) {
                    if (align >= 0 && align <= 2) {
                      Assembler.program.align(align);
                      if (!Assembler.program.addSymbol(Assembler.segment, id))
                        Assembler.error("label '" + id + "' is already defined");
                      else {
                        for (int i = 0; i < size; i++)
                          Assembler.program.addByte(Assembler.segment, (byte) 0);
                      }
                    } else
                      Assembler.error("invalid align value: '" + align + "', expected 0 (byte), 1 (half) or 2 (word)");
                  } else
                    Assembler.error(".comm/.common directive can only appear in bss segment");
                :}
             ;

DataMode    ::= D_BYTE:d
                {: RESULT = (String)d; :}
             |  D_HALF:d
                {: RESULT = (String)d; :}
             |  D_WORD:d
                {: RESULT = (String)d; :}
             ;

DataList    ::= Expr:e
                {:
                  ArrayList<Integer> l = new ArrayList<Integer>();
                  l.add(e);
                  RESULT = l;
                :}
             |  DataList:l Delimiter Expr:e
                {:
                  l.add(e);
                  RESULT = l;
                :}
             ;

/*
  DIRECTIVES
*/

Directive   ::= SectionDir
             |  SymbolDir
             |  AlignDir
             |  DOT Id:id
                {: Assembler.error("invalid directive: '." + id + "'"); :}
             ;

/*
  .section [{.text, .data, .rodata, .bss}]
*/

SectionDir  ::= D_SECTION Section
             |  Section
             ;

/*
  .text
  .data
  .rodata
  .bss
*/
Section     ::= D_TEXT:s
                {: Assembler.segment = Segment.TEXT; :}
             |  D_DATA:s
                {: Assembler.segment = Segment.DATA; :}
             |  D_RODATA:s
                {: Assembler.segment = Segment.RODATA; :}
             |  D_BSS:s
                {: Assembler.segment = Segment.BSS; :}
             ;

/*
  .globl id
*/

SymbolDir   ::= D_GLOBL Id:id
                {:
                  if(!Assembler.program.addGlobal(id))
                    Assembler.error("label '" + id + "' is already defined as global");
                :}
             ;

/*
  .align n
  .balign n
*/

AlignDir    ::= D_ALIGN Number:e
                {:
                  if (!Assembler.inTextSegment()) {
                    if (e >= 0 && e <= 2)
                      Assembler.program.align(e);
                    else
                      Assembler.error("invalid align value: '" + e + "', expected 0 (byte), 1 (half) or 2 (word)");
                  } else
                    Assembler.error(".align/.p2align directives can not appear in text segment");
                :}
             |  D_BALIGN Number:e
                {:
                  if (!Assembler.inTextSegment()) {
                    if (e > 0)
                      Assembler.program.balign(e);
                    else
                      Assembler.error("invalid align value: '" + e + "', expected value > 0");
                  } else
                    Assembler.error(".balign directive can not appear in text segment");
                :}
             ;

/*
    VALUES
*/

Expr        ::= Expr:e1 PLUS Expr:e2
                {: RESULT = e1 + e2; :}
             |  Expr:e1 MINUS Expr:e2
                {: RESULT = e1 - e2; :}
             |  Expr:e1 TIMES Expr:e2
                {: RESULT = e1 * e2; :}
             |  Expr:e1 DIVIDE Expr:e2
                {: RESULT = e1 / e2; :}
             |  Expr:e1 MOD Expr:e2
                {: RESULT = e1 % e2; :}
             |  Expr:e1 SLL Expr:e2
                {: RESULT = e1 << e2; :}
             |  Expr:e1 SRL Expr:e2
                {: RESULT = e1 >>> e2; :}
             |  Expr:e1 SRA Expr:e2
                {: RESULT = e1 >> e2; :}
             |  Expr:e1 AND Expr:e2
                {: RESULT = e1 & e2; :}
             |  Expr:e1 OR Expr:e2
                {: RESULT = e1 | e2; :}
             |  Expr:e1 XOR Expr:e2
                {: RESULT = e1 ^ e2; :}
             |  LPAREN Expr:e RPAREN
                {: RESULT = e; :}
             |  MINUS Expr:e
                {: RESULT = -e; :}
                %prec UMINUS
             |  PLUS Expr:e
                {: RESULT = e; :}
                %prec UPLUS
             |  NEG Expr:e
                {: RESULT = ~e; :}
             |  Const:n
                {: RESULT = n; :}
             ;

Const       ::= Number:n
                {: RESULT = n; :}
             |  Character:c
                {: RESULT = c; :}
             ;

Id          ::= IDENTIFIER:id
                {: RESULT = (String)id; :}
             ;

Number      ::= NUMBER:n
                {: RESULT = (int)n; :}
             ;

Character   ::= CHARACTER:c
                {: RESULT = (int)(((char) c) & 0xff); :}
             ;

Str         ::= STRING:s
                {: RESULT = (String)s; :}
             ;

Register    ::= REGISTER:reg
                {: RESULT = (String)reg; :}
             ;

Delimiter   ::= COMMA
             |  Epsilon
             ;

Epsilon     ::= /* NOTHING */
             ;
