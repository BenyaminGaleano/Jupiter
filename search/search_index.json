{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"V-Sim \u00b6 V-Sim is a simple assembler and runtime simulator inspired by SPIM for programming in RISC-V assembly language and intended for educational purposes. One of the main goals was to make it functional and easy to use. Almost all the 32-bit base integer instruction set ( RV32I ) can be simulated, as well as the M and F extensions plus all the their respective pseudo-instructions. Dependencies \u00b6 V-Sim requires Java 8 SE (or later) SDK installed on your computer. Unix Installation \u00b6 To install or update V-Sim on a Unix system, you can use the (fancy) installation script. with cURL : $ curl https://git.io/fbpu0 -L -o vsim && chmod +x vsim && . ./vsim && rm vsim or Wget : $ wget -O vsim https://git.io/fbpu0 && chmod +x vsim && . ./vsim && rm vsim Windows Installation \u00b6 To install or update V-Sim on a Windows PC, you need to follow the steps below. 1. Download the lastest stable release from here . 2. Unzip and move all the files to your preferred directory, say C:\\vsim . 3. Add VSim.jar to CLASSPATH , using System Properties dialog System Properties > Environment variables > Create or append to CLASSPATH variable 4. Create a short convenient command for the simulator, using a batch file called vsim.bat (save this file in a directory in system PATH , e.g system32 ): @echo off java vsim.VSim %* Testing Installation \u00b6 To verify that V-Sim has been installed, open a terminal/command line and enter this: $ vsim -version which should output v1.0.3 if the installation was successful. Then you can follow the usage guide.","title":"Home"},{"location":"#v-sim","text":"V-Sim is a simple assembler and runtime simulator inspired by SPIM for programming in RISC-V assembly language and intended for educational purposes. One of the main goals was to make it functional and easy to use. Almost all the 32-bit base integer instruction set ( RV32I ) can be simulated, as well as the M and F extensions plus all the their respective pseudo-instructions.","title":"V-Sim"},{"location":"#dependencies","text":"V-Sim requires Java 8 SE (or later) SDK installed on your computer.","title":"Dependencies"},{"location":"#unix-installation","text":"To install or update V-Sim on a Unix system, you can use the (fancy) installation script. with cURL : $ curl https://git.io/fbpu0 -L -o vsim && chmod +x vsim && . ./vsim && rm vsim or Wget : $ wget -O vsim https://git.io/fbpu0 && chmod +x vsim && . ./vsim && rm vsim","title":"Unix Installation"},{"location":"#windows-installation","text":"To install or update V-Sim on a Windows PC, you need to follow the steps below. 1. Download the lastest stable release from here . 2. Unzip and move all the files to your preferred directory, say C:\\vsim . 3. Add VSim.jar to CLASSPATH , using System Properties dialog System Properties > Environment variables > Create or append to CLASSPATH variable 4. Create a short convenient command for the simulator, using a batch file called vsim.bat (save this file in a directory in system PATH , e.g system32 ): @echo off java vsim.VSim %*","title":"Windows Installation"},{"location":"#testing-installation","text":"To verify that V-Sim has been installed, open a terminal/command line and enter this: $ vsim -version which should output v1.0.3 if the installation was successful. Then you can follow the usage guide.","title":"Testing Installation"},{"location":"directives/","text":"Supported Directives \u00b6 V-Sim supports most common assembler directives, including those indicated here . Some directives like .word accepts an expr argument list, where expr follows this BNF grammar: expr ::= expr + expr # plus | expr - expr # minus | expr * expr # times | expr / expr # divide | expr % expr # remainder | expr << expr # shift left logical | expr >>> expr # shift right logical | expr >> expr # shift right arithmetic | expr & expr # bitwise and | expr | expr # bitwise or | expr ^ expr # bitwise xor | ( expr ) | - expr | + expr | ~ expr # bitwise not | const const ::= INTEGER # e.g 0, 12 | CHARACTER # e.g 'a', '\\n' | HEXADECIMAL # e.g 0xa | BINARY # e.g 0b1001 Also .float accepts a fexpr argument list, where fexpr follows this BNF grammar: fexpr ::= fexpr + fexpr # plus | fexpr - fexpr # minus | fexpr * fexpr # times | fexpr / fexpr # divide | fexpr % fexpr # remainder | ( fexpr ) | - fexpr | + fexpr | const const ::= FLOAT # e.g 3.1416 | HEXADECIMAL # (IEEE-754 hex representation) e.g 0x7f800000 (+inf) | BINARY # (IEEE-754 bin representation) e.g 0b0 (zero) | INTEGER # converted to float e.g 2 -> 2.0 .p2align \u00b6 Align next data item to a power of 2 byte boundary. Usage .p2align < alignval > Arguments alignval : {0=byte, 1=half, 2=word} Aliases .align .balign \u00b6 Align next data item to a byte boundary. Usage .balign < alignval > Arguments alignval : (should be > 0) Aliases none .zero \u00b6 Reserve the specified number of bytes. Usage .zero < expr > Arguments expr : (should be > 0) Aliases .space .section \u00b6 Emit section and make current. Usage .section < section > Arguments section : { .text , .data , .rodata , .bss } Aliases none .text \u00b6 Emit text section and make current. Usage .text Arguments none Aliases none .data \u00b6 Emit data section and make current. Usage .data Arguments none Aliases none .rodata \u00b6 Emit read-only data section and make current. Usage .rodata Arguments none Aliases none .bss \u00b6 Emit bss section and make current. Usage .bss Arguments none Aliases none .globl \u00b6 Store the listed symbol(s) to symbol table (scope GLOBAL ). Usage .globl symbol [, symbol ]* Arguments list : comma separated symbols Aliases .global .string \u00b6 Store the string and add null terminator. Usage .string < string > Arguments string : quoted string Aliases .asciiz , .asciz .byte \u00b6 Store the listed value(s) as 8 bit bytes. Usage .byte expr [, expr ]* Arguments list : 8-bit comma separated words Aliases none .half \u00b6 Store the listed value(s) as 16 bit halfwords. Usage .half expr [, expr ]* Arguments list : 16-bit comma separated words Aliases .short , .2byte .word \u00b6 Store the listed value(s) as 32 bit words. Usage .word expr [, expr ]* Arguments list : 32-bit comma separated words Aliases .long , .4byte .float \u00b6 Store the listed value(s) as 32 bit float values. Usage .float fexpr [, fexpr ]* Arguments list : 32-bit comma separated float words Aliases none","title":"Directives"},{"location":"directives/#supported-directives","text":"V-Sim supports most common assembler directives, including those indicated here . Some directives like .word accepts an expr argument list, where expr follows this BNF grammar: expr ::= expr + expr # plus | expr - expr # minus | expr * expr # times | expr / expr # divide | expr % expr # remainder | expr << expr # shift left logical | expr >>> expr # shift right logical | expr >> expr # shift right arithmetic | expr & expr # bitwise and | expr | expr # bitwise or | expr ^ expr # bitwise xor | ( expr ) | - expr | + expr | ~ expr # bitwise not | const const ::= INTEGER # e.g 0, 12 | CHARACTER # e.g 'a', '\\n' | HEXADECIMAL # e.g 0xa | BINARY # e.g 0b1001 Also .float accepts a fexpr argument list, where fexpr follows this BNF grammar: fexpr ::= fexpr + fexpr # plus | fexpr - fexpr # minus | fexpr * fexpr # times | fexpr / fexpr # divide | fexpr % fexpr # remainder | ( fexpr ) | - fexpr | + fexpr | const const ::= FLOAT # e.g 3.1416 | HEXADECIMAL # (IEEE-754 hex representation) e.g 0x7f800000 (+inf) | BINARY # (IEEE-754 bin representation) e.g 0b0 (zero) | INTEGER # converted to float e.g 2 -> 2.0","title":"Supported Directives"},{"location":"directives/#p2align","text":"Align next data item to a power of 2 byte boundary. Usage .p2align < alignval > Arguments alignval : {0=byte, 1=half, 2=word} Aliases .align","title":".p2align"},{"location":"directives/#balign","text":"Align next data item to a byte boundary. Usage .balign < alignval > Arguments alignval : (should be > 0) Aliases none","title":".balign"},{"location":"directives/#zero","text":"Reserve the specified number of bytes. Usage .zero < expr > Arguments expr : (should be > 0) Aliases .space","title":".zero"},{"location":"directives/#section","text":"Emit section and make current. Usage .section < section > Arguments section : { .text , .data , .rodata , .bss } Aliases none","title":".section"},{"location":"directives/#text","text":"Emit text section and make current. Usage .text Arguments none Aliases none","title":".text"},{"location":"directives/#data","text":"Emit data section and make current. Usage .data Arguments none Aliases none","title":".data"},{"location":"directives/#rodata","text":"Emit read-only data section and make current. Usage .rodata Arguments none Aliases none","title":".rodata"},{"location":"directives/#bss","text":"Emit bss section and make current. Usage .bss Arguments none Aliases none","title":".bss"},{"location":"directives/#globl","text":"Store the listed symbol(s) to symbol table (scope GLOBAL ). Usage .globl symbol [, symbol ]* Arguments list : comma separated symbols Aliases .global","title":".globl"},{"location":"directives/#string","text":"Store the string and add null terminator. Usage .string < string > Arguments string : quoted string Aliases .asciiz , .asciz","title":".string"},{"location":"directives/#byte","text":"Store the listed value(s) as 8 bit bytes. Usage .byte expr [, expr ]* Arguments list : 8-bit comma separated words Aliases none","title":".byte"},{"location":"directives/#half","text":"Store the listed value(s) as 16 bit halfwords. Usage .half expr [, expr ]* Arguments list : 16-bit comma separated words Aliases .short , .2byte","title":".half"},{"location":"directives/#word","text":"Store the listed value(s) as 32 bit words. Usage .word expr [, expr ]* Arguments list : 32-bit comma separated words Aliases .long , .4byte","title":".word"},{"location":"directives/#float","text":"Store the listed value(s) as 32 bit float values. Usage .float fexpr [, fexpr ]* Arguments list : 32-bit comma separated float words Aliases none","title":".float"},{"location":"ecalls/","text":"Ecall \u00b6 V-Sim currently supports a total of 25 environmental calls through ecall instruction. To use an environmental call, load the ecall code into register a0 and load any arguments into a1 - a7 or fa0 - fa7 (floating-point) registers. Print Int \u00b6 Prints integer in register a1 . Example .globl main .text main: li a0 , 1 # ecall code li a1 , 0xa # integer to print ecall Ecall Code a0 = 1 Arguments a1 = integer Print Float \u00b6 Prints float in register fa0 . Example .globl main .rodata PI: .float 3 .1416 .text main: li a0 , 2 # ecall code flw fa0 , PI , t0 # float to print ecall Ecall Code a0 = 2 Arguments fa0 = float Print String \u00b6 Prints null-terminated string whose address is in register a1 . Example .globl main .rodata msg: .asciiz \"Hello World!!!\" .text main: li a0, 4 # ecall code la a1, msg # string to print ecall Ecall Code a0 = 4 Arguments a1 = null-terminated string address Read Int \u00b6 Reads an integer from stdin and stores the result in register a0 . Example .globl main .text main: li a0, 5 # ecall code ecall Ecall Code a0 = 5 Arguments none Read Float \u00b6 Reads a float from stdin and stores the result in register fa0 . Example .globl main .text main: li a0 , 6 # ecall code ecall Ecall Code a0 = 6 Arguments none Read String \u00b6 It reads up to \\(length - 1\\) characters into a buffer whose address is in a1 and terminates the string with a null byte. Buffer size has to be at least \\(length\\) bytes. Example .globl main .data string: .zero 256 .text main: li a0 , 8 # ecall code la a1 , string # buffer address li a2 , 256 # length ecall Ecall Code a0 = 8 Arguments a1 = buffer address a2 = length Sbrk \u00b6 Stores a pointer to a block of memory containing \\(n\\) additional bytes in register a0 . This pointer is word aligned. Example .globl main .text main: li a0 , 9 # ecall code li a1 , 100 # number of bytes ecall Ecall Code a0 = 9 Arguments a1 = number of bytes Exit \u00b6 Stops a program from running. Example .globl main .text main: li a0 , 10 # ecall code ecall Ecall Code a0 = 10 Arguments none Print Char \u00b6 Prints a character whose ascii code is in register a1 . Example .globl main .text main: li a0 , 11 # ecall code li a1 , ' a ' # character to print ecall Ecall Code a0 = 11 Arguments a1 = ascii code Read Char \u00b6 Reads a character from stdin and stores the ascii code in register a0 . Example .globl main .text main: li a0 , 12 # ecall code ecall Ecall Code a0 = 12 Arguments none Open \u00b6 Opens a new file and obtains its file descriptor. Stores the file descriptor for the new file in register a0 . The file descriptor returned is always the smallest integer greater than zero that is still available. If a negative value is returned, then there was an error opening the file. Maximum number of open files: 32 . Example .globl main .rodata # open flags O_RDWR: .word 0 b0000100 O_CREAT: .word 0 b0100000 O_EXCL: .word 0 b1000000 # pathname path: \" example.txt \" .text main: li a0 , 13 # ecall code la a1 , path # pathname address lw a2 , O_RDWR # load O_RDWR open flag lw t0 , O_CREAT # load O_CREAT open flag lw t1 , O_EXCL # load O_EXCL open flag or a2 , a2 , t0 # set a2 = O_RDWR | O_CREAT or a2 , a2 , t1 # set a2 = O_RDWR | O_CREAT | O_EXCL ecall Ecall Code a0 = 13 Arguments a1 = pathname address a2 = open flags Open Flags Name Code Description O_RDONLY 0b0000001 Open the file so that it is read only O_WRONLY 0b0000010 Open the file so that it is write only O_RDWR 0b0000100 Open the file so that it can be read from and written to O_APPEND 0b0001000 Append new information to the end of the file O_TRUNC 0b0010000 Initially clear all data from the file O_CREAT 0b0100000 If the file does not exist, create it O_EXCL 0b1000000 Combined with the O_CREAT option, it ensures that the caller must create the file. If file already exists, the call will fail Read \u00b6 Reads data into a buffer whose address is in register a2 . Stores the number of bytes that were read in register a0 . If value is negative, then an error occurred. Example .globl main .data read: .zero 1024 .text main: li a0 , 14 # ecall code li a1 , 1 # file descriptor la a2 , read # buffer address li a3 , 10 # number of bytes to read ecall Ecall Code a0 = 14 Arguments a1 = file descriptor a2 = buffer address a3 = number of bytes to read Write \u00b6 Writes data out of a buffer whose address is in register a2 . Stores the number of bytes that were written in register a0 . If value is negative, then an error occurred. Example .globl main .data write: .asciiz \"Hello World\" .text main: li a0 , 15 # ecall code li a1 , 1 # file descriptor la a2 , write # buffer address li a3 , 12 # number of bytes to write ecall Ecall Code a0 = 15 Arguments a1 = file descriptor a2 = buffer address a3 = number of bytes to write Close \u00b6 Close an open file descriptor. Stores a 0 upon success in register a0 , and a -1 upon failure. Example .globl main .text main: li a0 , 16 # ecall code li a1 , 1 # file descriptor ecall Ecall Code a0 = 16 Arguments a1 = file descriptor Exit2 \u00b6 Stops the program from running and takes an argument, which is the value that V-Sim uses in its call on exit. Example .globl main .text main: li a0 , 17 # ecall code li a1 , 1 # status code value ecall Ecall Code a0 = 17 Arguments a1 = status code Sleep \u00b6 Causes the V-Sim Java thread to sleep for (at least) the specified number of milliseconds in register a1 . This timing will not be precise, as the Java implementation will add some overhead. Example .globl main .text main: li a0 , 18 # ecall code li a1 , 1000 # sleep for 1 second ecall Ecall Code a0 = 18 Arguments a1 = number of milliseconds Cwd \u00b6 Stores the current working directory in a buffer whose address is in register a1 . Example .globl main .data cwd: .zero 1024 .text main: li a0 , 19 # ecall code la a1 , cwd # buffer address ecall Ecall Code a0 = 19 Arguments a1 = buffer address Time \u00b6 Stores the system time. a0 contains the low order 32 bits of system time and a1 high order 32 bits of system time. Example .globl main .text main: li a0 , 20 # ecall code ecall Ecall Code a0 = 20 Arguments none Print Hex \u00b6 Prints integer in register a1 in hex representation. Displayed value is 8 hexadecimal digits, left-padding with zeroes if necessary. Example .globl main .text main: li a0 , 21 # ecall code li a1 , 0xa # integer to print in hex ecall Ecall Code a0 = 21 Arguments a1 = integer Print Binary \u00b6 Prints integer in register a1 in binary representation. Displayed value is 32 binary digits, left-padding with zeroes if necessary. Example .globl main .text main: li a0 , 22 # ecall code li a1 , 0xa # integer to print in binary ecall Ecall Code a0 = 22 Arguments a1 = integer Print Unsigned \u00b6 Prints unsigned integer in register a1 . Example .globl main .text main: li a0 , 23 # ecall code li a1 , 0xa # integer to print (unsigned) ecall Ecall Code a0 = 23 Arguments a1 = integer Set Seed \u00b6 Sets the seed of the corresponding underlying Java pseudorandom number generator (java.util.Random). Example .globl main .text main: li a0 , 24 # ecall code li a1 , 123 # seed value ecall Ecall Code a0 = 24 Arguments a1 = seed Random Int \u00b6 Stores the next pseudorandom, uniformly distributed int value from this random number generator's sequence, in register a0 . Example .globl main .text main: li a0 , 25 # ecall code ecall Ecall Code a0 = 25 Arguments none Random Int Range \u00b6 Stores the next pseudorandom, uniformly distributed int value from this random number generator's sequence, in register a0 . The next pseudorandom value will be in [ a1 , a2 ] range. Example .globl main .text main: li a0 , 26 # ecall code li a1 , 10 # lower bound li a2 , 100 # upper bound ecall Ecall Code a0 = 26 Arguments a1 = lower bound of range a2 = upper bound of range Random Float \u00b6 Stores the next pseudorandom, uniformly distributed float value in the range [0.0, 1.0] from this random number generator's sequence, in register a0 . Example .globl main .text main: li a0 , 27 # ecall code ecall Ecall Code a0 = 27 Arguments none","title":"Environmental Calls"},{"location":"ecalls/#ecall","text":"V-Sim currently supports a total of 25 environmental calls through ecall instruction. To use an environmental call, load the ecall code into register a0 and load any arguments into a1 - a7 or fa0 - fa7 (floating-point) registers.","title":"Ecall"},{"location":"ecalls/#print-int","text":"Prints integer in register a1 . Example .globl main .text main: li a0 , 1 # ecall code li a1 , 0xa # integer to print ecall Ecall Code a0 = 1 Arguments a1 = integer","title":"Print Int"},{"location":"ecalls/#print-float","text":"Prints float in register fa0 . Example .globl main .rodata PI: .float 3 .1416 .text main: li a0 , 2 # ecall code flw fa0 , PI , t0 # float to print ecall Ecall Code a0 = 2 Arguments fa0 = float","title":"Print Float"},{"location":"ecalls/#print-string","text":"Prints null-terminated string whose address is in register a1 . Example .globl main .rodata msg: .asciiz \"Hello World!!!\" .text main: li a0, 4 # ecall code la a1, msg # string to print ecall Ecall Code a0 = 4 Arguments a1 = null-terminated string address","title":"Print String"},{"location":"ecalls/#read-int","text":"Reads an integer from stdin and stores the result in register a0 . Example .globl main .text main: li a0, 5 # ecall code ecall Ecall Code a0 = 5 Arguments none","title":"Read Int"},{"location":"ecalls/#read-float","text":"Reads a float from stdin and stores the result in register fa0 . Example .globl main .text main: li a0 , 6 # ecall code ecall Ecall Code a0 = 6 Arguments none","title":"Read Float"},{"location":"ecalls/#read-string","text":"It reads up to \\(length - 1\\) characters into a buffer whose address is in a1 and terminates the string with a null byte. Buffer size has to be at least \\(length\\) bytes. Example .globl main .data string: .zero 256 .text main: li a0 , 8 # ecall code la a1 , string # buffer address li a2 , 256 # length ecall Ecall Code a0 = 8 Arguments a1 = buffer address a2 = length","title":"Read String"},{"location":"ecalls/#sbrk","text":"Stores a pointer to a block of memory containing \\(n\\) additional bytes in register a0 . This pointer is word aligned. Example .globl main .text main: li a0 , 9 # ecall code li a1 , 100 # number of bytes ecall Ecall Code a0 = 9 Arguments a1 = number of bytes","title":"Sbrk"},{"location":"ecalls/#exit","text":"Stops a program from running. Example .globl main .text main: li a0 , 10 # ecall code ecall Ecall Code a0 = 10 Arguments none","title":"Exit"},{"location":"ecalls/#print-char","text":"Prints a character whose ascii code is in register a1 . Example .globl main .text main: li a0 , 11 # ecall code li a1 , ' a ' # character to print ecall Ecall Code a0 = 11 Arguments a1 = ascii code","title":"Print Char"},{"location":"ecalls/#read-char","text":"Reads a character from stdin and stores the ascii code in register a0 . Example .globl main .text main: li a0 , 12 # ecall code ecall Ecall Code a0 = 12 Arguments none","title":"Read Char"},{"location":"ecalls/#open","text":"Opens a new file and obtains its file descriptor. Stores the file descriptor for the new file in register a0 . The file descriptor returned is always the smallest integer greater than zero that is still available. If a negative value is returned, then there was an error opening the file. Maximum number of open files: 32 . Example .globl main .rodata # open flags O_RDWR: .word 0 b0000100 O_CREAT: .word 0 b0100000 O_EXCL: .word 0 b1000000 # pathname path: \" example.txt \" .text main: li a0 , 13 # ecall code la a1 , path # pathname address lw a2 , O_RDWR # load O_RDWR open flag lw t0 , O_CREAT # load O_CREAT open flag lw t1 , O_EXCL # load O_EXCL open flag or a2 , a2 , t0 # set a2 = O_RDWR | O_CREAT or a2 , a2 , t1 # set a2 = O_RDWR | O_CREAT | O_EXCL ecall Ecall Code a0 = 13 Arguments a1 = pathname address a2 = open flags Open Flags Name Code Description O_RDONLY 0b0000001 Open the file so that it is read only O_WRONLY 0b0000010 Open the file so that it is write only O_RDWR 0b0000100 Open the file so that it can be read from and written to O_APPEND 0b0001000 Append new information to the end of the file O_TRUNC 0b0010000 Initially clear all data from the file O_CREAT 0b0100000 If the file does not exist, create it O_EXCL 0b1000000 Combined with the O_CREAT option, it ensures that the caller must create the file. If file already exists, the call will fail","title":"Open"},{"location":"ecalls/#read","text":"Reads data into a buffer whose address is in register a2 . Stores the number of bytes that were read in register a0 . If value is negative, then an error occurred. Example .globl main .data read: .zero 1024 .text main: li a0 , 14 # ecall code li a1 , 1 # file descriptor la a2 , read # buffer address li a3 , 10 # number of bytes to read ecall Ecall Code a0 = 14 Arguments a1 = file descriptor a2 = buffer address a3 = number of bytes to read","title":"Read"},{"location":"ecalls/#write","text":"Writes data out of a buffer whose address is in register a2 . Stores the number of bytes that were written in register a0 . If value is negative, then an error occurred. Example .globl main .data write: .asciiz \"Hello World\" .text main: li a0 , 15 # ecall code li a1 , 1 # file descriptor la a2 , write # buffer address li a3 , 12 # number of bytes to write ecall Ecall Code a0 = 15 Arguments a1 = file descriptor a2 = buffer address a3 = number of bytes to write","title":"Write"},{"location":"ecalls/#close","text":"Close an open file descriptor. Stores a 0 upon success in register a0 , and a -1 upon failure. Example .globl main .text main: li a0 , 16 # ecall code li a1 , 1 # file descriptor ecall Ecall Code a0 = 16 Arguments a1 = file descriptor","title":"Close"},{"location":"ecalls/#exit2","text":"Stops the program from running and takes an argument, which is the value that V-Sim uses in its call on exit. Example .globl main .text main: li a0 , 17 # ecall code li a1 , 1 # status code value ecall Ecall Code a0 = 17 Arguments a1 = status code","title":"Exit2"},{"location":"ecalls/#sleep","text":"Causes the V-Sim Java thread to sleep for (at least) the specified number of milliseconds in register a1 . This timing will not be precise, as the Java implementation will add some overhead. Example .globl main .text main: li a0 , 18 # ecall code li a1 , 1000 # sleep for 1 second ecall Ecall Code a0 = 18 Arguments a1 = number of milliseconds","title":"Sleep"},{"location":"ecalls/#cwd","text":"Stores the current working directory in a buffer whose address is in register a1 . Example .globl main .data cwd: .zero 1024 .text main: li a0 , 19 # ecall code la a1 , cwd # buffer address ecall Ecall Code a0 = 19 Arguments a1 = buffer address","title":"Cwd"},{"location":"ecalls/#time","text":"Stores the system time. a0 contains the low order 32 bits of system time and a1 high order 32 bits of system time. Example .globl main .text main: li a0 , 20 # ecall code ecall Ecall Code a0 = 20 Arguments none","title":"Time"},{"location":"ecalls/#print-hex","text":"Prints integer in register a1 in hex representation. Displayed value is 8 hexadecimal digits, left-padding with zeroes if necessary. Example .globl main .text main: li a0 , 21 # ecall code li a1 , 0xa # integer to print in hex ecall Ecall Code a0 = 21 Arguments a1 = integer","title":"Print Hex"},{"location":"ecalls/#print-binary","text":"Prints integer in register a1 in binary representation. Displayed value is 32 binary digits, left-padding with zeroes if necessary. Example .globl main .text main: li a0 , 22 # ecall code li a1 , 0xa # integer to print in binary ecall Ecall Code a0 = 22 Arguments a1 = integer","title":"Print Binary"},{"location":"ecalls/#print-unsigned","text":"Prints unsigned integer in register a1 . Example .globl main .text main: li a0 , 23 # ecall code li a1 , 0xa # integer to print (unsigned) ecall Ecall Code a0 = 23 Arguments a1 = integer","title":"Print Unsigned"},{"location":"ecalls/#set-seed","text":"Sets the seed of the corresponding underlying Java pseudorandom number generator (java.util.Random). Example .globl main .text main: li a0 , 24 # ecall code li a1 , 123 # seed value ecall Ecall Code a0 = 24 Arguments a1 = seed","title":"Set Seed"},{"location":"ecalls/#random-int","text":"Stores the next pseudorandom, uniformly distributed int value from this random number generator's sequence, in register a0 . Example .globl main .text main: li a0 , 25 # ecall code ecall Ecall Code a0 = 25 Arguments none","title":"Random Int"},{"location":"ecalls/#random-int-range","text":"Stores the next pseudorandom, uniformly distributed int value from this random number generator's sequence, in register a0 . The next pseudorandom value will be in [ a1 , a2 ] range. Example .globl main .text main: li a0 , 26 # ecall code li a1 , 10 # lower bound li a2 , 100 # upper bound ecall Ecall Code a0 = 26 Arguments a1 = lower bound of range a2 = upper bound of range","title":"Random Int Range"},{"location":"ecalls/#random-float","text":"Stores the next pseudorandom, uniformly distributed float value in the range [0.0, 1.0] from this random number generator's sequence, in register a0 . Example .globl main .text main: li a0 , 27 # ecall code ecall Ecall Code a0 = 27 Arguments none","title":"Random Float"},{"location":"license/","text":"License \u00b6 Copyright (C) 2018 Andr\u00e9s Castellanos This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"License"},{"location":"license/#license","text":"Copyright (C) 2018 Andr\u00e9s Castellanos This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"License"},{"location":"usage/","text":"Basic Usage \u00b6 Once the simulator has been installed, you can get familiar with the CLI opening a terminal and putting the following vsim -help , that will output something like: $ vsim -help _ __ _____ | | / /___/ __ ( _ ) _ _ | | / /___/ \\ \\/ / ' \\ | ___/ /___/_/_/_/_/ RISC-V Assembler & Runtime Simulator usage: vsim [ options ] <files> available options: -bare bare machine ( no pseudo-ops ) -debug start the debugger -dump DUMP dump machine code to a file -help show this help message and exit -iset print available RISC-V instructions and exit -nocolor do not colorize output -notitle do not print title and copyright notice -quiet do not print warnings -start START start program at global label ( default: main ) -usage USAGE print usage of an instruction and exit -version show the simulator version and exit As you can see there are some options that you can pass to the simulator, for example -help was the one that you used previously. Here is a detailed table of each option: Option Description -bare bare machine mode, no pseudo-instructions available (TAL) -debug start the debugger after assembling all files -dump DUMP dump all the generated machine code to a file -help show the simulator help message and exit -iset print the available/implemented RISC-V instructions and exit -nocolor do not colorize output (only applicable for Linux users) -notitle do not print title and copyright notice (useful if redirecting or piping program output) -quiet do not print warnings during the simulation -start START start program at global label (default: main) -usage USAGE print detailed usage and description of an instruction and exit -version show the simulator version and exit Now we can try an example, the legendary fibonacci program. Download and save the file with the name fibonacci.s and put this in the terminal vsim fibonacci.s that will output something like: $ vsim fibonacci.s _ __ _____ | | / /___/ __ ( _ ) _ _ | | / /___/ \\ \\/ / ' \\ | ___/ /___/_/_/_/_/ RISC-V Assembler & Runtime Simulator GPL-3.0 License Copyright ( c ) 2018 Andres Castellanos All Rights Reserved See the file LICENSE for a full copyright notice Please enter a number: Because this program is using the Read Int environmental call, the program asks you to enter a number, you can enter for example the number 9 and the result will be: $ vsim fibonacci.s _ __ _____ | | / /___/ __ ( _ ) _ _ | | / /___/ \\ \\/ / ' \\ | ___/ /___/_/_/_/_/ RISC-V Assembler & Runtime Simulator Please enter a number: 9 The 9 fibonnaci number is: 34 vsim: exit ( 0 ) And that is the basic usage of the V-Sim simulator, you can also assemble and simulate several files at the same time, the only restriction is that you always have to define a global main label, even if it is a single file as this tells V-Sim where to start the simulation. Alternatively you can define a global label with another name and pass the -start <labelname> option to the simulator e.g. ##################### # example.s # ##################### .globl start .rodata msg: .asciiz \"hello world\" .text start: li a0 , 4 la a1 , msg ecall li a0 , 10 ecall $ vsim -start start example.s _ __ _____ | | / /___/ __ ( _ ) _ _ | | / /___/ \\ \\/ / ' \\ | ___/ /___/_/_/_/_/ RISC-V Assembler & Runtime Simulator hello world vsim: exit ( 0 ) Support Material The RISC-V Reader RISC-V Green Card","title":"Using V-Sim"},{"location":"usage/#basic-usage","text":"Once the simulator has been installed, you can get familiar with the CLI opening a terminal and putting the following vsim -help , that will output something like: $ vsim -help _ __ _____ | | / /___/ __ ( _ ) _ _ | | / /___/ \\ \\/ / ' \\ | ___/ /___/_/_/_/_/ RISC-V Assembler & Runtime Simulator usage: vsim [ options ] <files> available options: -bare bare machine ( no pseudo-ops ) -debug start the debugger -dump DUMP dump machine code to a file -help show this help message and exit -iset print available RISC-V instructions and exit -nocolor do not colorize output -notitle do not print title and copyright notice -quiet do not print warnings -start START start program at global label ( default: main ) -usage USAGE print usage of an instruction and exit -version show the simulator version and exit As you can see there are some options that you can pass to the simulator, for example -help was the one that you used previously. Here is a detailed table of each option: Option Description -bare bare machine mode, no pseudo-instructions available (TAL) -debug start the debugger after assembling all files -dump DUMP dump all the generated machine code to a file -help show the simulator help message and exit -iset print the available/implemented RISC-V instructions and exit -nocolor do not colorize output (only applicable for Linux users) -notitle do not print title and copyright notice (useful if redirecting or piping program output) -quiet do not print warnings during the simulation -start START start program at global label (default: main) -usage USAGE print detailed usage and description of an instruction and exit -version show the simulator version and exit Now we can try an example, the legendary fibonacci program. Download and save the file with the name fibonacci.s and put this in the terminal vsim fibonacci.s that will output something like: $ vsim fibonacci.s _ __ _____ | | / /___/ __ ( _ ) _ _ | | / /___/ \\ \\/ / ' \\ | ___/ /___/_/_/_/_/ RISC-V Assembler & Runtime Simulator GPL-3.0 License Copyright ( c ) 2018 Andres Castellanos All Rights Reserved See the file LICENSE for a full copyright notice Please enter a number: Because this program is using the Read Int environmental call, the program asks you to enter a number, you can enter for example the number 9 and the result will be: $ vsim fibonacci.s _ __ _____ | | / /___/ __ ( _ ) _ _ | | / /___/ \\ \\/ / ' \\ | ___/ /___/_/_/_/_/ RISC-V Assembler & Runtime Simulator Please enter a number: 9 The 9 fibonnaci number is: 34 vsim: exit ( 0 ) And that is the basic usage of the V-Sim simulator, you can also assemble and simulate several files at the same time, the only restriction is that you always have to define a global main label, even if it is a single file as this tells V-Sim where to start the simulation. Alternatively you can define a global label with another name and pass the -start <labelname> option to the simulator e.g. ##################### # example.s # ##################### .globl start .rodata msg: .asciiz \"hello world\" .text start: li a0 , 4 la a1 , msg ecall li a0 , 10 ecall $ vsim -start start example.s _ __ _____ | | / /___/ __ ( _ ) _ _ | | / /___/ \\ \\/ / ' \\ | ___/ /___/_/_/_/_/ RISC-V Assembler & Runtime Simulator hello world vsim: exit ( 0 ) Support Material The RISC-V Reader RISC-V Green Card","title":"Basic Usage"}]}